{"meta":{"title":"sym blog","subtitle":"keep trying","description":"hard work will payoff","author":"Nyan Shen","url":"https://nyanshen.github.io","root":"/"},"pages":[{"title":"404","date":"2019-07-27T03:32:07.000Z","updated":"2019-08-06T05:34:40.007Z","comments":true,"path":"404/index.html","permalink":"https://nyanshen.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-10T12:51:04.000Z","updated":"2019-08-11T00:36:19.882Z","comments":true,"path":"categories/index.html","permalink":"https://nyanshen.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-10T12:47:47.000Z","updated":"2019-08-11T00:36:19.882Z","comments":true,"path":"tags/index.html","permalink":"https://nyanshen.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-08-10T12:52:13.000Z","updated":"2019-08-11T00:36:19.882Z","comments":true,"path":"about/index.html","permalink":"https://nyanshen.github.io/about/index.html","excerpt":"","text":""},{"title":"search","date":"2019-07-27T03:31:55.000Z","updated":"2019-08-06T05:34:40.010Z","comments":true,"path":"search/index.html","permalink":"https://nyanshen.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"jest mock axios complex implement","slug":"jest mock axios complex implement","date":"2019-08-14T03:26:30.000Z","updated":"2019-08-14T03:26:16.590Z","comments":true,"path":"2019/08/14/jest mock axios complex implement/","link":"","permalink":"https://nyanshen.github.io/2019/08/14/jest mock axios complex implement/","excerpt":"","text":"1. mock axiosto implement this, we need ensure we have an axios file in your project.filename must be axios, axios.js or axios.ts 123456// axios.tsconst mockAxios: any = jest.genMockFromModule(\"axios\");mockAxios.create = jest.fn(() =&gt; mockAxios);export default mockAxios; 2. mock some service data;you can get the mock data according to the special url . 1234567891011const mockData: any = &#123; \"/api/sample/data\": &#123; data: &#123; &#125;, status: 200 &#125;&#125;export const getMockDataByUrl = (url: string) =&gt; &#123; return mockData[url];&#125; 3. mock axios request method1234567891011// axios.tsimport &#123;getMockDataByUrl&#125; from \"service\";mockAxios.request = (params: any) =&gt; &#123; const mockData = getMockDataByUrl(params.url); return new Promise((resolve) =&gt; &#123; process.nextTick(() =&gt; &#123; resolve(mockData) &#125;) &#125;)&#125;","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"axios","slug":"axios","permalink":"https://nyanshen.github.io/tags/axios/"}]},{"title":"testing-library/react define renderer like renderwithRouter, renderWithRedux","slug":"testing-library: react define renderer","date":"2019-08-13T00:36:13.000Z","updated":"2019-08-13T12:37:17.838Z","comments":true,"path":"2019/08/13/testing-library: react define renderer/","link":"","permalink":"https://nyanshen.github.io/2019/08/13/testing-library: react define renderer/","excerpt":"","text":"1. mock renderWithRouter123456789101112131415// this is a handy function that I would utilize for any component// that relies on the router being in contextconst renderWithRouter = ( ui, &#123;route = '/', history = createMemoryHistory(&#123;initialEntries: [route]&#125;)&#125; = &#123;&#125;,) =&gt; &#123; return &#123; ...render(&lt;Router history=&#123;history&#125;&gt;&#123;ui&#125;&lt;/Router&gt;), // adding `history` to the returned utilities to allow us // to reference it in our tests (just try to avoid using // this to test implementation details). history, &#125;&#125;export defalut renderWithRouter 2. relative test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React from 'react'import &#123;withRouter&#125; from 'react-router'import &#123;Link, Route, Router, Switch&#125; from 'react-router-dom'import &#123;createMemoryHistory&#125; from 'history'import &#123;render, fireEvent&#125; from '@testing-library/react'const About = () =&gt; &lt;div&gt;You are on the about page&lt;/div&gt;const Home = () =&gt; &lt;div&gt;You are home&lt;/div&gt;const NoMatch = () =&gt; &lt;div&gt;No match&lt;/div&gt;const LocationDisplay = withRouter((&#123;location&#125;) =&gt; ( &lt;div data-testid=\"location-display\"&gt;&#123;location.pathname&#125;&lt;/div&gt;))function App() &#123; return ( &lt;div&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route component=&#123;NoMatch&#125; /&gt; &lt;/Switch&gt; &lt;LocationDisplay /&gt; &lt;/div&gt; )&#125;// Ok, so here's what your tests might look like// this is a handy function that I would utilize for any component// that relies on the router being in contextfunction renderWithRouter( ui, &#123;route = '/', history = createMemoryHistory(&#123;initialEntries: [route]&#125;)&#125; = &#123;&#125;,) &#123; return &#123; ...render(&lt;Router history=&#123;history&#125;&gt;&#123;ui&#125;&lt;/Router&gt;), // adding `history` to the returned utilities to allow us // to reference it in our tests (just try to avoid using // this to test implementation details). history, &#125;&#125;test('full app rendering/navigating', () =&gt; &#123; const &#123;container, getByText&#125; = renderWithRouter(&lt;App /&gt;) // normally I'd use a data-testid, but just wanted to show this is also possible expect(container.innerHTML).toMatch('You are home') const leftClick = &#123;button: 0&#125; fireEvent.click(getByText(/about/i), leftClick) // normally I'd use a data-testid, but just wanted to show this is also possible expect(container.innerHTML).toMatch('You are on the about page')&#125;)test('landing on a bad page', () =&gt; &#123; const &#123;container&#125; = renderWithRouter(&lt;App /&gt;, &#123; route: '/something-that-does-not-match', &#125;) // normally I'd use a data-testid, but just wanted to show this is also possible expect(container.innerHTML).toMatch('No match')&#125;)test('rendering a component that uses withRouter', () =&gt; &#123; const route = '/some-route' const &#123;getByTestId&#125; = renderWithRouter(&lt;LocationDisplay /&gt;, &#123;route&#125;) expect(getByTestId('location-display').textContent).toBe(route)&#125;) 3. render with redux1234const renderWithRedux = (ui, &#123; initialState, store = createStore(reducer, initialState), &#125; = &#123;&#125;) =&gt; (&#123; ...render(&lt;Provider store=&#123;store&#125;&gt;&#123;ui&#125;&lt;/Provider&gt;), store,&#125;);","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://nyanshen.github.io/tags/react-hooks/"}]},{"title":"testing-library/jest-dom config issue","slug":"testing library: jest-dom config issue","date":"2019-08-11T08:10:20.000Z","updated":"2019-08-13T12:39:03.055Z","comments":true,"path":"2019/08/11/testing library: jest-dom config issue/","link":"","permalink":"https://nyanshen.github.io/2019/08/11/testing library: jest-dom config issue/","excerpt":"","text":"1. running issuewhen I directly config the testing-library/jest-dom in jest.config.js,it will come as follow: TypeScript diagnostics (customize using [jest-config].globals.ts-jest.diagnostics option)Property ‘toBeInTheDocument’ does not exist on type ‘Matchers‘.read the intruduction here 2. configuring again then can use the library in global env1234567891011121314// config/setup-test.jsrequire(\"@testing-library/jest-dom/extend-expect\");// jest.config.js add globals&#123; globals: &#123; 'ts-jest': &#123; diagnostics: false &#125; &#125;, setupFilesAfterEnv: [ \"&lt;rootDir&gt;/config/setup-enzyme.js\", \"&lt;rootDir&gt;/config/setup-test.js\" ]&#125; 3. node version request it will run errors when the node version under 8.make sure you have the latest node version. 4. babel-plugin-react-remove-properties如果考量到 data-testid 被 build 後會被看見，也可以透過 babel-plugin-react-remove-properties 將 data-testid 移除。","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://nyanshen.github.io/tags/react-hooks/"}]},{"title":"webpack 4.x common config","slug":"webpack common config","date":"2019-08-10T02:50:22.000Z","updated":"2019-08-11T00:36:19.881Z","comments":true,"path":"2019/08/10/webpack common config/","link":"","permalink":"https://nyanshen.github.io/2019/08/10/webpack common config/","excerpt":"","text":"1. install dependencieswebpack basic 1npm i webpack weebpack-cli webpack-merge -D html packing plugin 1npm i html-webpack-plugin -D css packing plugin, It supports On-Demand-Loading of CSS and SourceMaps. 123npm i style-loader css-loader postcss-loader scss-loader autoprefixer -Dnpm i mini-css-extract-plugin OptimizeCssAssetsPlugin -Dnpm i sass-resources-loader node-sass -D scss-loader将scss样式转换为css, postcss-loader对转好的css样式做一些列处理 css-loader将处理好的css样式转为字符串， style-loader将css-loader打包好的样式字符串，载入html的style标签上。 miniCssExtractLoader将html里的样式，抽取出来放到link标签引入 autoprefixer样式智能加后缀 build after clean 1npm i clean-webpack-plugin -D 加载图片资源 1npm i file-loader url-loader -D 打包体积优化 1npm i terser-webpack-plugin optimize-css-assets-webpack-plugin -D hash: 每次编译compilation对象的hash,全局一致,跟每次编译有关，跟单个文件无关，不推荐使用 chunkhash: chunk的hash,chunk中包含的任一模块发生改变，则chunkhash发生变化，推荐使用。 contenthash: css文件特有的hash值，是根据css文件内容计算出来的，css发生变化则其值发生变化，推荐css导出中使用 分析打包结果 1npm i webpack-bundle-analyzer -D 2. webpack.base.config12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const path = require(\"path\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const isDev = process.env.NODE_ENV === \"development\";const styleLoader = isDev ? \"style-loader\" : MiniCssExtractPlugin.loader;module.exports = &#123; mode: isDev ? \"development\" : \"production\", entry: \"./src/index.tsx\", resolve: &#123; extensions: [\".ts\", \".tsx\", \".js\", \".json\"], alias: &#123; \"@assets\": path.resolve(__dirname, \"src/assets/\"), \"@components\": path.resolve(__dirname, \"src/components/\") &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/, exclude: /node_modules/, loader: \"awesome-typescript-loader\" &#125;, &#123; test: /\\.js$/, enforce: \"pre\", loader: \"source-map-loader\" &#125;, &#123; test: /\\.css$/, use: [ styleLoader, &#123; loader: \"css-loader\", options: &#123; importLoaders: 1 &#125; &#125;, \"postcss-loader\" ] &#125;, &#123; test: /\\.scss$/, use: [ styleLoader, &#123; loader: \"css-loader\", options: &#123; importLoaders: 3 &#125; &#125;, \"postcss-loader\", \"sass-loader\", &#123; loader: \"sass-resources-loader\", options: &#123; resources: [ \"./src/styles/_variables.scss\", \"./src/styles/_mixins.scss\" ] &#125; &#125; ] &#125;, &#123; test: /\\.(png|jpe?g|svg|gif)$/, use: &#123; loader: \"url-loader\", options: &#123; limit: 3 * 1024 //3k, 超过3k不被处理为base64 &#125; &#125; &#125;, &#123; test: /\\.(eot|woff|woff2|ttf)$/, loader: \"file-loader\", query: &#123; name: \"assets/[name].[hash].[ext]\" &#125; &#125; ] &#125;, externals: &#123; \"react\": \"React\", \"react-dom\": \"ReactDOM\" &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: \"./src/index.html\", filename: \"index.html\" &#125;) ]&#125; 3. webpack.development.config12345678910111213141516171819202122232425262728293031const webpack = require(\"webpack\");module.exports = &#123; devServer: &#123; port: 3000, hot: true, open: \"Chrome\", inline: true, //自动刷新 historyApiFallback: true, overlay: &#123; warnings: true, errors: true &#125;, proxy: &#123; \"/api/*\": &#123; target: \"http://localhost:12306\", changeOrigin: false, secure: false &#125; &#125; &#125;, plugins: [ new webpack.DefinePlugin(&#123; \"process.env.NODE_ENV\": JSON.stringify(\"development\") &#125;), //开启HMR(热替换功能,替换更新部分,不重载页面！) new webpack.HotModuleReplacementPlugin(), //显示模块相对路径 new webpack.NamedModulesPlugin() ]&#125; 4. webpack.production.config1234567891011121314151617181920212223242526272829303132333435363738394041424344const path = require(\"path\");const webpack = require(\"webpack\");const TerserPlugin = require(\"terser-webpack-plugin\");const &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const OptimizeCssAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;module.exports = &#123; output: &#123; path: path.resolve(__dirname, './dist'), filename: \"js/bundle.[chunkhash:8].js\", chunkFilename: 'js/[name].[id].[chunkhash:8].js' &#125;, plugins: [ new CleanWebpackPlugin(), new MiniCssExtractPlugin(&#123; filename: \"css/[name].[contenthash:8].css\", chunkFilename: \"css/[id].[contenthash:8].css\" &#125;), new OptimizeCssAssetsPlugin(), new webpack.DefinePlugin(&#123; \"process.env.NODE_ENV\": JSON.stringify(\"production\") &#125;), new BundleAnalyzerPlugin() ], optimization: &#123; minimizer: [ new TerserPlugin(&#123; cache: true, parallel: true, terserOptions: &#123; unused: true, // 删除无用代码 drop_debugger: true, drop_console: true, dead_code: true &#125; &#125;) ], splitChunks: &#123; chunks: 'all' &#125; &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://nyanshen.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://nyanshen.github.io/tags/webpack/"}]},{"title":"testing reack hooks","slug":"react hooks testing","date":"2019-08-09T21:25:30.000Z","updated":"2019-08-11T00:36:19.878Z","comments":true,"path":"2019/08/10/react hooks testing/","link":"","permalink":"https://nyanshen.github.io/2019/08/10/react hooks testing/","excerpt":"","text":"1. Can we use Jest or Enzyme?Hooks can only be called inside the body of a function component. (https://fb.me/react-invalid-hook-call)The error above means that Hooks are not yet supported in Enzyme as seen in this issue here.As a result, we cannot use Enzyme to carry out component tests for React Hooks. So what can be used? 2. Introducing react-testing-libraryreact-testing-library is a very light-weight solution for testing React components. It extends upon react-dom and react-dom/test-utils to provide light utility functions. It encourages you to write tests that closely resemble how your react components are used. 3. InstallationThis module is distributed via npm which is bundled with node and should be installed as one of your project’s devDependencies: 1npm install --save-dev @testing-library/react This library has peerDependencies listings for react and react-dom. 4. Suppressing unnecessary warnings on React DOM 16.8There is a known compatibility issue with React DOM 16.8 where you will see the following warning: 1Warning: An update to ComponentName inside a test was not wrapped in act(...). If you cannot upgrade to React DOM 16.9, you may suppress the warnings by adding the following snippet to your test configuration learn more 123456789101112131415// this is just a little hack to silence a warning that we'll get until we// upgrade to 16.9: https://github.com/facebook/react/pull/14853const originalError = console.errorbeforeAll(() =&gt; &#123; console.error = (...args) =&gt; &#123; if (/Warning.*not wrapped in act/.test(args[0])) &#123; return &#125; originalError.call(console, ...args) &#125;&#125;)afterAll(() =&gt; &#123; console.error = originalError&#125;) 4. configuring some import12import '@testing-library/react/cleanup-after-each' // deprecatedimport '@testing-library/jest-dom/extend-expect' // not work in jest config file when use typescript these imports are something you’d normally configure Jest to import for you.automatically. Learn more in the setup docs: https://testing-library.com/docs/react-testing-library/setup#cleanup sample test Header1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import * as React from \"react\";import &#123;useState&#125; from \"react\";const Header = () =&gt; &#123; const [value, setValue] = useState&lt;string&gt;(\"\"); const handleInputChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123; setValue(event.target.value) &#125; return ( &lt;div className=\"header\"&gt; &lt;div className=\"header-content\"&gt; TodoList &lt;input value=&#123;value&#125; data-testid=\"header_input\" onChange=&#123;handleInputChange&#125; /&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Header;// Header.test.tsximport * as React from \"react\";import &#123; render, fireEvent &#125; from \"@testing-library/react\";import \"@testing-library/jest-dom/extend-expect\";import Header from \"../Header\";let wrapper = null;describe(\"test Header component\", () =&gt; &#123; beforeEach(() =&gt; &#123; wrapper = render(&lt;Header /&gt;); &#125;) it(\"should contain title 'TodoList'\", () =&gt; &#123; const &#123;getByText&#125; = wrapper; const title = \"TodoList\"; expect(getByText(title)).toBeInTheDocument(); &#125;) it(\"input initial value should be empty\", () =&gt; &#123; const &#123;getByTestId&#125; = wrapper; expect(getByTestId(\"header_input\").value).toEqual(\"\"); &#125;) it(\"value should be set when input some text\", () =&gt; &#123; const &#123;getByTestId&#125; = wrapper; const inputElem = getByTestId(\"header_input\"); const context = \"input text test\"; fireEvent.change(inputElem, &#123;target: &#123; value: context &#125;&#125;); expect(inputElem.value).toEqual(context); &#125;)&#125;)","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://nyanshen.github.io/tags/react-hooks/"}]},{"title":"jest enzyme unit test react","slug":"unit test for react","date":"2019-08-09T10:10:12.000Z","updated":"2019-08-11T00:36:19.881Z","comments":true,"path":"2019/08/09/unit test for react/","link":"","permalink":"https://nyanshen.github.io/2019/08/09/unit test for react/","excerpt":"","text":"1. 测试类型 单元测试：指的是以原件的单元为单位，对软件进行测试。单元可以是一个函数，也可以是一个模块或一个组件，基本特征就是只要输入不变，必定返回同样的输出。一个软件越容易些单元测试，就表明它的模块化结构越好，给模块之间的耦合越弱。React的组件化和函数式编程，天生适合进行单元测试 功能测试：相当于是黑盒测试，测试者不了解程序的内部情况，不需要具备编程语言的专门知识，只知道程序的输入、输出和功能，从用户的角度针对软件界面、功能和外部结构进行测试，不考虑内部的逻辑 集成测试：在单元测试的基础上，将所有模块按照设计要求组装成子系统或者系统，进行测试 冒烟测试：在正式全面的测试之前，对主要功能进行的与测试，确认主要功能是否满足需要，软件是否能正常运行 2. 开发模式 TDD: 测试驱动开发，英文为Testing Driven Development，强调的是一种开发方式，以测试来驱动整个项目，即先根据接口完成测试编写，然后在完成功能是要不断通过测试，最终目的是通过所有测试 BDD: 行为驱动测试，英文为Behavior Driven Development，强调的是写测试的风格，即测试要写的像自然语言，让项目的各个成员甚至产品都能看懂测试，甚至编写测试 TDD和BDD有各自的使用场景，BDD一般偏向于系统功能和业务逻辑的自动化测试设计；而TDD在快速开发并测试功能模块的过程中则更加高效，以快速完成开发为目的。 3. JestJest是Facebook开源的一个前端测试框架，主要用于React和React Native的单元测试，已被集成在create-react-app中。Jest特点： 易用性：基于Jasmine，提供断言库，支持多种测试风格 适应性：Jest是模块化、可扩展和可配置的 沙箱和快照：Jest内置了JSDOM，能够模拟浏览器环境，并且并行执行 快照测试：Jest能够对React组件树进行序列化，生成对应的字符串快照，通过比较字符串提供高性能的UI检测 Mock系统：Jest实现了一个强大的Mock系统，支持自动和手动mock 支持异步代码测试：支持Promise和async/await 自动生成静态分析结果：内置Istanbul，测试代码覆盖率，并生成对应的报告 4. EnzymeEnzyme是Airbnb开源的React测试工具库库，它功能过对官方的测试工具库ReactTestUtils的二次封装，提供了一套简洁强大的 API，并内置Cheerio，实现了jQuery风格的方式进行DOM 处理，开发体验十分友好。在开源社区有超高人气，同时也获得了React 官方的推荐。 三种渲染方法 shallow：浅渲染，是对官方的Shallow Renderer的封装。将组件渲染成虚拟DOM对象，只会渲染第一层，子组件将不会被渲染出来，使得效率非常高。不需要DOM环境， 并可以使用jQuery的方式访问组件的信息 render：静态渲染，它将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库解析这段字符串，并返回一个Cheerio的实例对象，可以用来分析组件的html结构 mount：完全渲染，它将组件渲染加载成一个真实的DOM节点，用来测试DOM API的交互和组件的生命周期。用到了jsdom来模拟浏览器环境 三种方法中，shallow和mount因为返回的是DOM对象，可以用simulate进行交互模拟，而render方法不可以。一般shallow方法就可以满足需求，如果需要对子组件进行判断，需要使用render，如果需要测试组件的生命周期，需要使用mount方法。 常用方法simulate(event, mock)：模拟事件，用来触发事件，event为事件名称，mock为一个event objectinstance()：返回组件的实例find(selector)：根据选择器查找节点，selector可以是CSS中的选择器，或者是组件的构造函数，组件的display name等at(index)：返回一个渲染过的对象get(index)：返回一个react node，要测试它，需要重新渲染contains(nodeOrNodes)：当前对象是否包含参数重点 node，参数类型为react对象或对象数组text()：返回当前组件的文本内容html()： 返回当前组件的HTML代码形式props()：返回根组件的所有属性prop(key)：返回根组件的指定属性state()：返回根组件的状态setState(nextState)：设置根组件的状态setProps(nextProps)：设置根组件的属性 5. config explain setupFilesAfterEnv：配置文件，在运行测试案例代码之前，Jest会先运行这里的配置文件来初始化指定的测试环境 moduleFileExtensions：代表支持加载的文件名 testPathIgnorePatterns：用正则来匹配不用测试的文件 testRegex：正则表示的测试文件，测试文件的格式为xxx.test.js等 collectCoverage：是否生成测试覆盖报告，如果开启，会增加测试的时间 collectCoverageFrom：生成测试覆盖报告是检测的覆盖文件 moduleNameMapper：代表需要被Mock的资源名称 transform：用babel-jest来编译文件，生成ES6/7的语法， ts-jest编译typescript文件 6. jest对象 jest.fn(implementation)：返回一个全新没有使用过的mock function，这个function在被调用的时候会记录很多和函数调用有关的信息 jest.mock(moduleName, factory, options)：用来mock一些模块或者文件 jest.spyOn(object, methodName)：返回一个mock function，和jest.fn相似，但是能够追踪object[methodName]的调用信息，类似Sinon 7. 常见断言expect(value)：要测试一个值进行断言的时候，要使用expect对值进行包裹toBe(value)：使用Object.is来进行比较，如果进行浮点数的比较，要使用toBeCloseTonot：用来取反toEqual(value)：用于对象的深比较toMatch(regexpOrString)：用来检查字符串是否匹配，可以是正则表达式或者字符串toContain(item)：用来判断item是否在一个数组中，也可以用于字符串的判断toBeNull(value)：只匹配nulltoBeUndefined(value)：只匹配undefinedtoBeDefined(value)：与toBeUndefined相反toBeTruthy(value)：匹配任何使if语句为真的值toBeFalsy(value)：匹配任何使if语句为假的值toBeGreaterThan(number)： 大于toBeGreaterThanOrEqual(number)：大于等于toBeLessThan(number)：小于toBeLessThanOrEqual(number)：小于等于toBeInstanceOf(class)：判断是不是class的实例anything(value)：匹配除了null和undefined以外的所有值resolves：用来取出promise为fulfilled时包裹的值，支持链式调用rejects：用来取出promise为rejected时包裹的值，支持链式调用toHaveBeenCalled()：用来判断mock function是否被调用过toHaveBeenCalledTimes(number)：用来判断mock function被调用的次数assertions(number)：验证在一个测试用例中有number个断言被调用extend(matchers)：自定义一些断言 8. 测试场景对组件节点进行测试12345678910111213141516171819202122it('should has Button', () =&gt; &#123; const &#123; wrapper &#125; = setup(); expect(wrapper.find('Button').length).toBe(2);&#125;);it('should render 2 item', () =&gt; &#123; const &#123; wrapper &#125; = setupByRender(); expect(wrapper.find('button').length).toBe(2);&#125;);it('should render item equal', () =&gt; &#123; const &#123; wrapper &#125; = setupByMount(); wrapper.find('.item-text').forEach((node, index) =&gt; &#123; expect(node.text()).toBe(wrapper.props().list[index]) &#125;);&#125;);it('click item to be done', () =&gt; &#123; const &#123; wrapper &#125; = setupByMount(); wrapper.find('Button').at(0).simulate('click'); expect(props.deleteTodo).toBeCalled();&#125;); 使用 snapshot 进行 UI 测试 1234567it('renders correctly', () =&gt; &#123; const tree = renderer .create(&lt;TodoList &#123;...props&#125; /&gt;) .toJSON(); expect(tree).toMatchSnapshot();&#125;); 测试组件的内部函数 123456789101112131415it('calls component handleTest', () =&gt; &#123; // class中使用箭头函数来定义方法 const &#123; wrapper &#125; = setup(); const spyFunction = jest.spyOn(wrapper.instance(), 'handleTest'); wrapper.instance().handleTest(); expect(spyFunction).toHaveBeenCalled(); spyFunction.mockRestore();&#125;);it('calls component handleTest2', () =&gt; &#123; //在constructor使用bind来定义方法 const spyFunction = jest.spyOn(TodoList.prototype, 'handleTest2'); const &#123; wrapper &#125; = setup(); wrapper.instance().handleTest2(); expect(spyFunction).toHaveBeenCalled(); spyFunction.mockRestore();&#125;);","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"react","slug":"react","permalink":"https://nyanshen.github.io/tags/react/"},{"name":"enzyme","slug":"enzyme","permalink":"https://nyanshen.github.io/tags/enzyme/"}]},{"title":"jest config issue assets && alias","slug":"jest config issue","date":"2019-08-08T12:21:50.000Z","updated":"2019-08-11T03:08:22.751Z","comments":true,"path":"2019/08/08/jest config issue/","link":"","permalink":"https://nyanshen.github.io/2019/08/08/jest config issue/","excerpt":"","text":"1. path mappingIf you use “baseUrl” and “paths” options in your tsconfig file, you should make sure the “moduleNameMapper” option in your Jest config is setup accordingly. ts-jest provides a helper to transform the mapping from tsconfig to Jest config format, but it needs the .js version of the config file. 2. sample hereWith the below config in your tsconfig: 1234567891011121314151617&#123; \"compilerOptions\": &#123; \"paths\": &#123; \"@App/*\": [\"src/*\"], \"common/*\": [\"common/*\"] &#125; &#125;&#125;// jest.config.jsmodule.exports = &#123; // [...] moduleNameMapper: &#123; '^@App/(.*)$': '&lt;rootDir&gt;/src/$1', '^common/(.*)$': '&lt;rootDir&gt;/common/$1' &#125;&#125;; 3. Handling Static AssetsNext, let’s configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren’t particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it’s better to mock a proxy for your className lookups. 12345678910\"moduleNameMapper\": &#123; \"\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$\": \"&lt;rootDir&gt;/__mocks__/fileMock.js\", \"\\\\.(css|less)$\": \"&lt;rootDir&gt;/__mocks__/styleMock.js\" &#125;// __mocks__/styleMock.jsmodule.exports = &#123;&#125;;// __mocks__/fileMock.jsmodule.exports = 'test-file-stub';","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"typescript","slug":"typescript","permalink":"https://nyanshen.github.io/tags/typescript/"}]},{"title":"react typescript jest config (二)","slug":"react typescript jest config (二)","date":"2019-08-07T11:11:55.000Z","updated":"2019-08-11T00:36:19.880Z","comments":true,"path":"2019/08/07/react typescript jest config (二)/","link":"","permalink":"https://nyanshen.github.io/2019/08/07/react typescript jest config (二)/","excerpt":"","text":"1. Add a basic TypeScript configuration filetsconfig.jsonYou’ll want to bring your TypeScript files together - both the code you’ll be writing as well as any necessary declaration files. To do this, you’ll need to create a tsconfig.json which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named tsconfig.json and fill it with the following contents: 123456789101112131415161718192021222324252627282930// tsconfig.json&#123; \"compilerOptions\": &#123; \"outDir\": \"./dist/\", \"target\": \"es5\", \"module\": \"commonJs\", // 组织代码方式 \"sourceMap\": true, \"allowJs\": true, \"jsx\": \"react\", \"removeComments\": true, // 编译 js 的时候，删除掉注释 \"typeRoots\": [], // 默认所有可见的\"@types\"包会在编译过程中被包含进来 /** *添加types后，目前加index.tsx后会报错 */ \"types\": [\"node\", \"lodash\"], // 只有被列出来的包才会被包含进来 \"baseUrl\": \".\" &#125;, \"exclude\": [ // 不需要编译 \"node_modules\", \"dist\", \"webpack\", \"jest\", \"enzyme\", \"**/*.test.ts\", \"**/*.test.tsx\" ], \"include\": [ \"./src/**/*\" ]&#125; tsconfig module click here 2. webpack basic config123456789101112131415161718192021222324252627282930313233343536// webpack.bask.config.jsconst path = require(\"path\");const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: \"./src/index.tsx\", resolve: &#123; extensions: [\".ts\", \".tsx\", \".js\", \".json\"], alias: &#123; components: path.resolve(__dirname, \"src/components/\") &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/, exclude: /node_modules/, loader: \"awesome-typescript-loader\" &#125;, &#123; test: /\\.js$/, enforce: \"pre\", loader: \"source-map-loader\" &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;) ], externals: &#123; react: \"React\", reactDom: \"ReactDom\" &#125;&#125; 3. jest enzyme basic configsetup enzyme config 1234// config/setup-test.tsimport &#123;configure&#125; from \"enzyme\";import * as Adapter from \"anzyme-adater-react-16\"configure(&#123;adapter: new Adapter()&#125;); 1234567891011121314151617181920212223module.exports = &#123; \"roots\": [ // 要测试的根目录默认为&lt;rootDir&gt; \"&lt;rootDir&gt;/src\" ], \"transform\": &#123; \"^.+\\\\.tsx?$\": \"ts-jest\" &#125;, // 设置识别哪些文件是测试文件（正则形式），与testMatch互斥 \"testRegex\": \"(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.tsx?$\", \"moduleFileExtensions\": [ \"ts\", \"tsx\", \"js\", \"jsx\", \"json\", \"node\" ], // 测试环境，默认值是：jsdom，可修改为node testRnviroment: \"jsdom\", // setup enzyme setupFilesAfterEnv: [\"&lt;rootDir&gt;/src/config/setup-test.ts\"], snapshotSerializers: [\"enzyme-to-json/serializer\"]&#125; 4. jest-enzyme config（这一点实现有问题，请暂时忽略）The best setup is to use jest-environment-enzyme 1npm i jest-environment-enzyme jest-enzyme -D jest config add like: 1234567&#123; \"setupTestFrameworkScriptFile\": \"jest-enzyme\", \"testEnvironment\": \"enzyme\", \"testEnvironmentOptions\": &#123; \"enzymeAdapter\": \"react16\" &#125;&#125; If you prefer not to use the environment, you can also do this: 123&#123; \"setupFilesAfterEnv\": ['./node_modules/jest-enzyme/lib/index.js'],&#125; As with Create React App, when using jest-enzyme with TypeScript and ts-jest, you’ll need to add a setupTests.ts file to your app that explicitly imports jest-enzyme, and point the setupTestFrameworkScriptFile field in your jest.config.js or package.json. 123456// setupTests.tsimport 'jest-enzyme';// jest.config.js&#123; \"setupTestFrameworkScriptFile\": \"./src/config/setupTests.ts\" &#125; ** notice: 测试组件文件后缀为.tsx **“setupTestFrameworkScriptFile” was replace by configuration “setupFilesAfterEnv”, which supports multi path. 123&#123; \"setupFilesAfterEnv\": ['./node_modules/jest-enzyme/lib/index.js', 'jest-enzyme'],&#125;","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"typescript","slug":"typescript","permalink":"https://nyanshen.github.io/tags/typescript/"},{"name":"react","slug":"react","permalink":"https://nyanshen.github.io/tags/react/"},{"name":"enzyme","slug":"enzyme","permalink":"https://nyanshen.github.io/tags/enzyme/"}]},{"title":"react typescript jest config (一)","slug":"react typescript jest config (一)","date":"2019-08-06T09:20:10.000Z","updated":"2019-08-11T00:36:19.879Z","comments":true,"path":"2019/08/06/react typescript jest config (一)/","link":"","permalink":"https://nyanshen.github.io/2019/08/06/react typescript jest config (一)/","excerpt":"","text":"1. initialize projectcreate a folder projectNow we’ll turn this folder into an npm package. 1npm init -y This creates a package.json file with default values. 2. Install react typescript dependenciesFirst ensure Webpack is installed. 1npm i webpack webpack-cli webpack-merge html-webpack-plugin webpack-dev-server -D Webpack is a tool that will bundle your code and optionally all of its dependencies into a single .js file. Let’s now add React and React-DOM, along with their declaration files, as dependencies to your package.json file: 12npm i react react-dom npm i @types/react @types/react-dom -D That @types/ prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like “react”, it will look inside of the react package itself; however, not all packages include declaration files, so TypeScript also looks in the @types/react package as well. You’ll see that we won’t even have to think about this later on. Next, we’ll add development-time dependencies on the ts-loader and source-map-loader. 123npm i typescript ts-loader source-map-loader -Dornpm i awesome-typescript-loader source-map-loader -D Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript’s standard configuration file named tsconfig.json. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating its own sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code. Please note that ts-loader is not the only loader for typescript. You could instead use awesome-typescript-loaderRead about the differences between them:https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loaderNotice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with npm link typescript, but this is a less common scenario. 3. Install jest enzyme dependencies1、install jest dependencies 1npm i jest @types/jest ts-jest -D 2、 install enzyme dependencies 12npm i enzyme enzyme-adapter-react-16 jest-enzyme enzyme-to-json -Dnpm i @types/enzyme @types/enzyme-adapter-react-16 -D 4. install another compiler for typescript use babel dependenciesinstall babel loader 123npm i @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript -Dnpm i babel-loader babel-plugin-import -D config babel 1234567891011module.exports=&#123; presets: [ \"env\", \"react\", \"typascript\" ], plugins: [ [\"lodash\"], [\"import\", &#123;libraryName: \"antd\", style: true&#125;] ]&#125; use babel loader instaed of ts-loader","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"typescript","slug":"typescript","permalink":"https://nyanshen.github.io/tags/typescript/"},{"name":"react","slug":"react","permalink":"https://nyanshen.github.io/tags/react/"},{"name":"enzyme","slug":"enzyme","permalink":"https://nyanshen.github.io/tags/enzyme/"}]},{"title":"jest test todo list","slug":"jest test todo list","date":"2019-08-04T01:23:11.000Z","updated":"2019-08-11T00:36:19.875Z","comments":true,"path":"2019/08/04/jest test todo list/","link":"","permalink":"https://nyanshen.github.io/2019/08/04/jest test todo list/","excerpt":"","text":"1. Header组件单元测试header组件主要由一个title,和一个输入框组成，输入框有以下几个处理情况： 输入框初始化为空 输入框内容为空时，回车事件不做任何操作 输入框内容不为空时，回车事件会调用添加todo的函数，并且清空输入框内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// Header.jsxexport default class Header extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: \"\" &#125; this.handleKeyUp = this.handleKeyUp.bind(this); this.handleInputChange = this.handleInputChange.bind(this); &#125; handleKeyUp(e) &#123; const &#123; value &#125; = this.state; if (e.keyCode === 13 &amp;&amp; value) &#123; this.props.addUndoItem(value) this.setState(&#123;value: \"\"&#125;) &#125; &#125; handleInputChange(e) &#123; this.setState(&#123; value: e.target.value &#125;) &#125; render() &#123; const &#123; value &#125; = this.state; return ( &lt;div className=\"header\"&gt; &lt;div className=\"header-content\"&gt;TodoList &lt;input value=&#123;value&#125; data-test=\"input\" className=\"header-input\" placeholder=\"add todo\" onKeyUp=&#123;this.handleKeyUp&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;// test/Header.test.jsximport React from \"react\";import &#123; shallow &#125; from \"enzyme\";import Header from \"../Header\";import &#123; findTestWrapper &#125; from \"common/util/testUtils\"describe(\"Header Componet Test\", () =&gt; &#123; it(\"样式渲染正常\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); expect(wrapper).toMatchSnapshot(); &#125;) it(\"组件包含输入框\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); expect(inputElem.length).toBe(1); &#125;) it(\"输入框内容初始化应该为空\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); expect(inputElem.prop(\"value\")).toEqual(\"\"); &#125;) it(\"输入框随用户输入时发生改变\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); /** * 模拟change事件，输入test nyan */ inputElem.simulate(\"change\", &#123; target: &#123; value: \"test nyan\" &#125; &#125;) expect(wrapper.state(\"value\")).toEqual(\"test nyan\"); &#125;) it(\"输入框没有内容时，回车时无反应\", () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); wrapper.setState(&#123; value: \"\" &#125;) inputElem.simulate(\"kepUp\", &#123; keyCode: 13 &#125;) expect(fn).not.toHaveBeenCalled(); &#125;) it(\"输入框有内容触发回车时，函数应该被调用\", () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); // 准备数据 wrapper.setState(&#123; value: \"jest react\" &#125;) /** * 设置keyUp的keyCode模拟回车 */ inputElem.simulate(\"keyUp\", &#123; keyCode: 13 &#125;) expect(fn).toHaveBeenCalled(); expect(fn).toHaveBeenLastCalledWith(\"jest react\"); // 最后的参数 &#125;) it(\"输入框有内容触发回车时，内容应该被清除\", () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); // 准备数据 wrapper.setState(&#123; value: \"jest react add one\" &#125;) /** * 设置keyUp的keyCode模拟回车 */ inputElem.simulate(\"keyUp\", &#123; keyCode: 13 &#125;) const newInputElem = wrapper.find(\"[data-test='input']\"); expect(newInputElem.prop(\"value\")).toBe(\"\"); &#125;)&#125;) 2. TodoList组件单元测试TodoList组件主要控制undoList数据状态的改变，实现改变数据项显示状态（输入框或文字）。 首先数据项undoList初始化为空 其次判断TodoList组件所包含那些子组件以及属性方法 每一个数据项都有修改和删除操作 通过状态的改变进行数据项修改 点击每一个数据项，会调用状态改变函数 当输入框失去焦点时，改变数据项的状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180import React from \"react\";import Header from \"../components/Header\"import UndoList from \"../components/UndoList\";export default class TodoList extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; undoList: [] &#125; this.deleteItem = this.deleteItem.bind(this); this.addUndoItem = this.addUndoItem.bind(this); this.changeStatus = this.changeStatus.bind(this); this.handleBlur = this.handleBlur.bind(this); this.handleValueChange = this.handleValueChange.bind(this); &#125; addUndoItem(value) &#123; this.setState(&#123; undoList: [...this.state.undoList, &#123; status: \"div\", value &#125;] &#125;) &#125; deleteItem(index) &#123; const newUndoList = [...this.state.undoList] newUndoList.splice(index, 1) this.setState(&#123; undoList: newUndoList &#125;) &#125; changeStatus(index) &#123; const newUndoList = this.state.undoList.map((item, listIndex) =&gt; &#123; if (listIndex === index) &#123; return &#123; ...item, status: \"input\" &#125; &#125; return &#123; ...item, status: \"div\" &#125; &#125;) this.setState(&#123; undoList: newUndoList &#125;) &#125; handleBlur(index) &#123; const newUndoList = this.state.undoList.map((item, listIndex) =&gt; &#123; if (listIndex === index) &#123; return &#123; ...item, status: \"div\" &#125; &#125; return item &#125;) this.setState(&#123; undoList: newUndoList &#125;) &#125; handleValueChange(index, value) &#123; const newUndoList = this.state.undoList.map((item, listIndex) =&gt; &#123; if (listIndex === index) &#123; return &#123; ...item, value &#125; &#125; return item &#125;) this.setState(&#123; undoList: newUndoList &#125;) &#125; render() &#123; const &#123; undoList &#125; = this.state; return ( &lt;&gt; &lt;Header addUndoItem=&#123;this.addUndoItem&#125; /&gt; &lt;UndoList list=&#123;undoList&#125; deleteItem=&#123;this.deleteItem&#125; changeStatus=&#123;this.changeStatus&#125; handleBlur=&#123;this.handleBlur&#125; handleValueChange=&#123;this.handleValueChange&#125; /&gt; &lt;/&gt; ) &#125;&#125;// todoList.test.jsimport React from \"react\";import &#123; shallow &#125; from \"enzyme\";import TodoList from \"../../../containers/TodoList\";describe(\"TodoList Comonent Test\", () =&gt; &#123; it(\"初始化列表为空\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); expect(wrapper.state(\"undoList\")).toEqual([]); &#125;) it(\"Header组件存在addUndoItem的属性\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const header = wrapper.find(\"Header\"); //expect(header.prop(\"addUndoItem\")).toBe(wrapper.instance().addUndoItem); expect(header.prop(\"addUndoItem\")).toBeTruthy(); &#125;) it(\"addUndoItem方法被调用时，undoList数据项新增\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); /** * const header = wrapper.find(\"Header\"); * const addFn = header.prop(\"addUndoItem\"); * addFn(\"add item one\"); * 这样操作，测试就会跟Header组件耦合（像集成测试），应该修改为一下方案 */ const content = \"add item one\" wrapper.instance().addUndoItem(content) expect(wrapper.state(\"undoList\").length).toBe(1); expect(wrapper.state(\"undoList\")[0]).toEqual(&#123; status: \"div\", value: content &#125;) &#125;) it(\"UndoList 组件应该有接收list，deleteItem，changeStatus, handleBlur属性\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const undoList = wrapper.find(\"UndoList\"); expect(undoList.prop(\"list\")).toBeTruthy(); expect(undoList.prop(\"deleteItem\")).toBeTruthy(); expect(undoList.prop(\"changeStatus\")).toBeTruthy(); expect(undoList.prop(\"handleBlur\")).toBeTruthy(); &#125;) it(\"deleteItem被执行时，应该删除对应数据项\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const data =[ &#123;status: \"div\",value: \"react\"&#125;, &#123;status: \"div\",value: \"ject\"&#125;, &#123;status: \"div\",value: \"enzyme\"&#125;, ] wrapper.setState(&#123;undoList: data&#125;); wrapper.instance().deleteItem(1); expect(wrapper.state(\"undoList\")).toEqual([data[0], data[2]]) &#125;) it(\"changeStatus被执行时，undoList数据项被修改\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const data =[ &#123;status: \"div\",value: \"react\"&#125;, &#123;status: \"div\",value: \"ject\"&#125;, &#123;status: \"div\",value: \"enzyme\"&#125;, ] wrapper.setState(&#123;undoList: data&#125;); wrapper.instance().changeStatus(1); expect(wrapper.state(\"undoList\")[1]).toEqual(&#123; ...data[1], status: \"input\" &#125;) &#125;) it(\"handleBlur被执行时，undoList数据项被修改\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const data =[ &#123;status: \"input\",value: \"react\"&#125;, &#123;status: \"div\",value: \"ject\"&#125;, &#123;status: \"div\",value: \"enzyme\"&#125;, ] wrapper.setState(&#123;undoList: data&#125;); wrapper.instance().handleBlur(0); expect(wrapper.state(\"undoList\")[0]).toEqual(&#123; ...data[0], status: \"div\" &#125;) &#125;)&#125;) 3. undoList组件单元测试undoList组件是TodoList组件的子组件，控制显示todoList数据，主要包含title、统计添加的todo数据项个数、显示添加的数据项，以及父亲组件传入修改的数据项。 当没有添加todo数据项时，count的长度为0 当添加了todo数据项时，显示数量以及对应的数据项 当有todo数据项时，每个数据项显示删除按钮 当有todo数据项时，点击数据项时触发改变数据项状态函数 当数据项状态为可修改时，失去焦点时触发失去失去焦点函数 当数据项状态为可修改时，修改数据时触发数据项值改变的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import React from \"react\";export default class UndoList extends React.Component &#123; render() &#123; const &#123; list, deleteItem, changeStatus, handleBlur, handleValueChange &#125; = this.props; return ( &lt;div className=\"undo-list\"&gt; &lt;div className=\"undo-list-title\"&gt; 正在进行 &lt;span className=\"undo-list-count\" data-test=\"count\"&gt;&#123;list.length&#125;&lt;/span&gt; &lt;/div&gt; &lt;ul className=\"undo-list-content\"&gt; &#123; list.map((item, index) =&gt; &#123; return ( &lt;li className=\"undo-list-item\" data-test=\"listItem\" key=&#123;`$&#123;item&#125;-$&#123;index&#125;`&#125; onClick=&#123;() =&gt; changeStatus(index)&#125; &gt; &#123;item.status === \"div\" ? item.value : ( &lt;input value=&#123;item.value&#125; data-test=\"input\" className=\"undo-list-input\" onBlur=&#123;() =&gt; handleBlur(index)&#125; onChange=&#123;(e) =&gt; handleValueChange(index, e.target.value)&#125; /&gt; )&#125; &lt;span className=\"undo-list-delete\" data-test=\"deleteItem\" onClick=&#123;(e) =&gt; &#123; e.stopPropagation() deleteItem(index) &#125;&#125;&gt;-&lt;/span&gt; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;// undoList.test.jsximport React from \"react\";import &#123; shallow &#125; from \"enzyme\";import UndoList from \"../../UndoList\";import &#123; findTestWrapper &#125; from \"../../../common/util/testUtils\";describe(\"UndoList Component Test\", () =&gt; &#123; it(\"当数据为空数组时，count为0，列表无内容\", () =&gt; &#123; const undoList = []; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const countElem = findTestWrapper(wrapper, \"count\"); const listItems = findTestWrapper(wrapper, \"listItem\"); expect(countElem.text()).toBe(\"0\"); expect(listItems.length).toEqual(0); &#125;) it(\"当数据不为空数组时，显示count，列表内容不为空\", () =&gt; &#123; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const countElem = findTestWrapper(wrapper, \"count\"); const listItems = findTestWrapper(wrapper, \"listItem\"); expect(countElem.text()).toBe(\"3\"); expect(listItems.length).toEqual(3); &#125;) it(\"当数据不为空数组时，应该有删除按钮\", () =&gt; &#123; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const deleteItem = findTestWrapper(wrapper, \"deleteItem\"); expect(deleteItem.length).toEqual(3); &#125;) it(\"当数据不为空数组时，点击某个删除按钮，调用删除方法\", () =&gt; &#123; const fn = jest.fn(); const index = 1; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; deleteItem=&#123;fn&#125; /&gt;); const deleteItem = findTestWrapper(wrapper, \"deleteItem\"); deleteItem.at(index).simulate(\"click\", &#123; stopPropagation: () =&gt; &#123; &#125; // 阻止事件冒泡 &#125;); expect(fn).toHaveBeenCalledWith(index); &#125;) it(\"当某一项被点击时，触发执行changeStatus函数\", () =&gt; &#123; const fn = jest.fn(); const index = 1; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; changeStatus=&#123;fn&#125; /&gt;); const changeStatus = findTestWrapper(wrapper, \"listItem\"); changeStatus.at(index).simulate(\"click\"); expect(fn).toHaveBeenCalledWith(index); &#125;) it(\"当某一项的状态为‘input’时，存在一个输入框\", () =&gt; &#123; const undoList = [ &#123; status: \"input\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); expect(inputElem.length).toBe(1); &#125;) it(\"当某一项失去焦点时，执行handleBlur函数\", () =&gt; &#123; const fn = jest.fn(); const undoList = [ &#123; status: \"input\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; handleBlur=&#123;fn&#125; /&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); inputElem.simulate(\"blur\"); expect(fn).toHaveBeenCalledWith(0); &#125;) it('当某一个输入框变更时，触发 handleValueChange 方法', () =&gt; &#123; const listData = [ &#123; status: 'input',value: 'jest' &#125;, ] const value = 'react'; const fn = jest.fn(); const wrapper = shallow(&lt;UndoList handleValueChange=&#123;fn&#125; list=&#123;listData&#125;/&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); inputElem.simulate('change', &#123; target: &#123;value&#125; &#125;); expect(fn).toHaveBeenLastCalledWith(0, value); &#125;);&#125;)","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"}]},{"title":"Jest Setup and Teardown","slug":"Jest Setup and Teardown","date":"2019-08-03T03:20:10.000Z","updated":"2019-08-11T00:36:19.873Z","comments":true,"path":"2019/08/03/Jest Setup and Teardown/","link":"","permalink":"https://nyanshen.github.io/2019/08/03/Jest Setup and Teardown/","excerpt":"","text":"1. Repeating Setup For Many TestsIf you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach.there is a Counter Class for test like: 12345678910111213141516171819export default class Counter &#123; constructor() &#123; this.number = 0 &#125; addOne() &#123; this.number += 1 &#125; minusOne() &#123; this.number -= 1 &#125; addTwo() &#123; this.number += 2 &#125; minusTwo() &#123; this.number -= 2 &#125;&#125; you might repeat to create the instance for counter, so we can use beforeEach to prepare. 1234567891011121314import Counter from \"./counter\"let counter = nullbeforeEach(() =&gt; &#123; console.log(\"beforeEach\") counter = new Counter()&#125;)afterEach(() =&gt; &#123; console.log(\"afterEach\")&#125;)test(\"test counter addOne\", () =&gt; &#123; console.log(\"test counter addOne\") counter.addOne() expect(counter.number).toBe(1)&#125;) 2. Scoping &amp;&amp; Order of execution of describe and test blocksBy default, the before and after blocks apply to every test in a file. You can also group tests together using a describe block. When they are inside a describe block, the before and after blocks only apply to the tests within that describe block. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import Counter from \"./counter\"// describe block Applies to all tests in this filedescribe(\"counter js test\", () =&gt; &#123; let counter = null; console.log(\"counter js test\") beforeAll(() =&gt; &#123; console.log(\"beforeAll\") &#125;) beforeEach(() =&gt; &#123; console.log(\"beforeEach\") counter = new Counter(); &#125;) afterEach(() =&gt; &#123; console.log(\"afterEach\") &#125;) afterAll(() =&gt; &#123; console.log(\"afterAll\") &#125;) describe(\"counter js test add\", () =&gt; &#123; console.log(\"counter js test add\") beforeAll(() =&gt; &#123; console.log(\"beforeAll add\") &#125;) beforeEach(() =&gt; &#123; console.log(\"beforeEach add\") &#125;) afterEach(() =&gt; &#123; console.log(\"afterEach add\") &#125;) afterAll(() =&gt; &#123; console.log(\"afterAll add\") &#125;) test(\"test counter addOne\", () =&gt; &#123; console.log(\"test counter addOne\") counter.addOne() expect(counter.number).toBe(1) &#125;) &#125;) describe(\"counter js test minus\", () =&gt; &#123; // // Applies only to tests in this describe block console.log(\"counter js test minus\") test(\"test counter minusOne\", () =&gt; &#123; console.log(\"counter js test minusOne\") counter.minusOne() expect(counter.number).toBe(-1) &#125;) test(\"test counter minusTwo\", () =&gt; &#123; console.log(\"counter js test minusTwo\") counter.minusTwo() expect(counter.number).toBe(-2) &#125;) &#125;)&#125;)// execute order/** * counter js test * counter js test add * counter js test munis * beforeAll * beforeAll add * beforeEach * beforeEach add * test counter addOne * afterEach add * afterEach * afterAll add * beforeEach * counter js test minusOne * afterEach * beforeEach * counter js test minusTwo * afterEach */ 3. General Advice If a test is failing, one of the first things to check should be whether the test is failing when it’s the only test that runs. In Jest it’s simple to run only one test - just temporarily change that test command to a test.only If you have a test that often fails when it’s run as part of a larger suite, but doesn’t fail when you run it alone, it’s a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with beforeEach. If you’re not sure whether some shared state is being modified, you can also try a beforeEach that just logs data.","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"}]},{"title":"jest-异步代码测试方法","slug":"jest-异步代码测试方法","date":"2019-08-02T01:00:10.000Z","updated":"2019-08-11T00:36:19.876Z","comments":true,"path":"2019/08/02/jest-异步代码测试方法/","link":"","permalink":"https://nyanshen.github.io/2019/08/02/jest-异步代码测试方法/","excerpt":"","text":"1. prepare fetch moduleLet’s implement a simple module that fetches success data from an API and returns the {success: true}. 12345678// fetchData.jsimport axios from \"axios\";export const fetchData = (fn) =&gt; &#123; axios.get('http://www.dell-lee.com/reactt/api/demo.json').then(res =&gt; &#123; fn(res.data) &#125;)&#125; In the above implementation we expect the fetchData.js module to return a promise. We chain a call to then to receive the data. 2. async function use callback type1234567// fetchData.test.jsimport &#123;fetchData&#125; from \"./fetchData.js\";test('fetchData return &#123;success: true&#125;', () =&gt; &#123; fetcchData((data) =&gt; &#123; expect(data).toEqual(&#123;success: true&#125;) &#125;)&#125;) npm run testactually it always execute successfully,because it won’t wait the async function finished. we can use done to ensure the test is execute finished. 1234567import &#123;fetchData&#125; from \"./fetchData.js\";test('fetchData return &#123;success: true&#125;', (done) =&gt; &#123; fetcchData((data) =&gt; &#123; expect(data).toEqual(&#123;success: true&#125;) done(); &#125;)&#125;) 3. return promise derectly1234567891011121314// fetchData.jsimport axios from \"axios\";export const fetchData = () =&gt; &#123; return axios.get('http://www.dell-lee.com/reactt/api/demo.json')&#125;// fetchData.test.jsimport &#123;fetchData&#125; from \"./fetchData.js\";test('fetchData return &#123;success: true&#125;', () =&gt; &#123; return fetcchData().then((res) =&gt; &#123; expect(res.data).toEqual(&#123;success: true&#125;) &#125;)&#125;) need to add return 4. Error handlingErrors can be handled using the .catch method. Make sure to add expect.assertions to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test: 12345678// fetchData.test.jstest('test fetchData return 404', () =&gt; &#123; // use assertions at least execute the expect method one time expect.assertions(1) return fetchData().catch((e) =&gt; &#123; expect(e.toString().indexOf('404') &gt; -1).toBe(true) &#125;)&#125;) 5. use resolvesThere is a less verbose way using resolves to unwrap the value of a fulfilled promise together with any other matcher. If the promise is rejected, the assertion will fail. 12345678// fetchData.test.jstest('test fetchData return &#123; success: true&#125;', () =&gt; &#123; return expect(fetchData()).resloves.toMatchObject(&#123; data: &#123; success: true &#125; &#125;)&#125;) use rejectsThe .rejects helper works like the .resolves helper. If the promise is fulfilled, the test will automatically fail. 1234// fetchData.test.jstest('test fetchData return 404', () =&gt; &#123; return expect(fetchData()).rejects.toThrow()&#125;) async/awaitWriting tests using the async/await syntax is easy. Here is how you’d write the same examples from before: 1234567891011121314151617181920// fetchData.test.jstest('test fetchData return &#123; success: true&#125;', async () =&gt; &#123; const result = await fetchData(); return expect(result.data).toEqual(&#123;success: true&#125;)&#125;)// async/await can also be used with `.resolves`.it('works with async/await and resolves', async () =&gt; &#123; expect.assertions(1); await expect(fetchData()).resolves.toEqual(&#123;success: true&#125;);&#125;);test('test fetchData return 404', async () =&gt; &#123; expect.assertions(1); try &#123; await fetchData(); &#125; catch(e) &#123; expect(e.toString()).toEqual(\"Error: Request faild with with status code 404\") &#125;&#125;)","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"}]},{"title":"es6 新特性","slug":"es6-新特性","date":"2019-08-01T12:34:14.000Z","updated":"2019-08-11T00:36:19.874Z","comments":true,"path":"2019/08/01/es6-新特性/","link":"","permalink":"https://nyanshen.github.io/2019/08/01/es6-新特性/","excerpt":"","text":"1. 类（class）这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 12345678910111213141516171819202122232425262728293031class Animal &#123; constructor(name, color) &#123; // 构造函数 this.name = name; this.color = color; &#125; toString() &#123; // toString方法 console.log(`name: $&#123;this.name&#125;, color: $&#123;this.color&#125;`); &#125; getName() &#123; // 取值 return this.name; &#125; setName(value) &#123; // 存值 this.name = value; &#125; getColor() &#123; // 取值 return this.color; &#125; setColor(value) &#123; // 存值 this.color = value; &#125;&#125;let animal = new Animal(\"cat\", \"white\");animal.toString(); // name: cat, color: whiteconsole.log(animal.hasOwnProperty('name')) // trueconsole.log(animal.hasOwnProperty('toString')) // falseconsole.log(animal.__proto__.hasOwnProperty('toString')) // true 2. super 和 extends使用新的super和extends关键字扩展类1234567891011121314151617181920212223class Cat extends Animal &#123; constructor(action = \"catch thing\",name, color) &#123; super(\"cat\", \"black\"); // super用作函数, 必须在this使用前调用 this.action = action; // Cat 类本身属性 &#125; toString() &#123; super.toString();// super用作对象 &#125; getAction() &#123; return this.action; &#125; setAction(value) &#123; this.action = value; &#125;&#125;let cat = new Cat(\"eat fish\");cat.toString(); // name: cat, color: whiteconsole.log(cat instanceOf Cat) // trueconsole.log(cat instanceOf Animal) // true 使用ES5编写同样功能的类123456789101112131415161718192021222324function Animal(name, color) &#123; this.name = name || \"cat\"; this.color = color || \"orange\";&#125;Animal.prototype.toString = function() &#123; console.log(`name: $&#123;this.name&#125;, color: $&#123;this.color&#125;`);&#125;function Cat (action, name, color) &#123; Animal.call(this, name, color); this.action = action || \"catch thing\";&#125;Cat.prototype = Object.create(Animal.prototype);Cat.prototype.constructor = Cat;Cat.prototype.toString = function() &#123; Tree.prototype.toString.call(this);&#125;Cat.prototype.setAction = function(value) &#123; this.action = value;&#125; 3. 模块化（Module）es5不支持原生的模块化，在es6模块作为重要的组成部分被添加进来。模块的共能主要由export和import组成。每一个模块都有自己的单独的作用域，模块之间的调用是通过export来规定模块对外暴露的接口，通过import来引用其他模块提供的接口。同时模块还创造了命名空间，防止函数的命名冲突。 导出（export）ES6允许在一个模块中使用export来导出多个变量和函数。 导出变量12345export let varible = \"test variable exprot\";export default varible;let name = \"cat\";let color = \"yellow\";export &#123;name, color&#125; 导出常量1export const NUMBER_LENGTH = 20 导出函数123export function myModuleFn(somParams) &#123; return somParams&#125; 导入（import）定义好模块的输出，就可以在另一个模块通过import导入 123import varible from \"test.js\"import &#123;myModuleFn&#125; from \"myModuleFn\";import &#123;name, color&#125; from \"./path/to/test.js\"; 4. 箭头函数（Arrow Function）=&gt;不只是function的简写，它还带来了其他好处。箭头函数与包围它的代码共享同一个this，能够帮你解决this的指向问题。有经验的javaScript开发者都熟悉var self = this或var that = this这种引用外围的this的模式。但=&gt;就不需要这种模式了。 不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做别的一些事（如卸载监听器），那么你必须保存这个引用。 箭头函数与普通函数的区别 箭头函数是匿名函数，不能作为构造函数，不能使用new 箭头函数不绑定arguments，取而代之用rest参数…解决 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。 箭头函数没有原型属性 箭头函数不能当做Generator函数,不能使用yield关键字 箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()普通函数的this指向调用它的那个对象 5. 模板字符串ES6支持模板字符串，使得字符串的拼接更加简洁、直观。 不使用模板字符串 1var name = &apos;your name is &apos; + first + &apos; &apos; + last; 使用模板字符串 1var name = `your name is $&#123;first&#125; $&#123;last&#125;`; 在ES6中通过${}就可以完成字符串拼接，只需要将变量放在大括号中。 7. 解构赋值解构赋值语法是Javascript的一种表达式，可以方便的从数组或对象中快速提取值赋给定义的变量。 获取数组的值从数据中获取值并赋值到的变量中，变量的顺序与数组中对象顺序对应 123456789var foo = [&#123;\"a\": \"one\"&#125;, \"two\", \"three\", \"four\"];var [one, two, three] = foo;console.log(one, two, three)// 如果你要忽略某些值， 你可以按照下面的写法获取你想要的值var [first, , , last] = foo;console.log(first, last)var [a, b] = [1, 2]console.log(a, b) 如果没有从数组中获取到值，可以为变量设置一个默认值。 12var a ,b;[a= 3, b=7]=[1] 获取对象的值1234567const student = &#123; name: \"Nyan\", age: 27, city: \"ShenZhen\"&#125;const &#123;name, age, city&#125; = student;console.log(name, age, city) 8. 延展操作符（Spread operator）延展操作符...可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开；还可以在构造对象时，将对象表达式按key-value方式展开。 语法 函数调用 1myFunction(...iterableObj) 数组构造或字符串 1[...iterableObj, '4', ...'hello', 6] 构造对象时，进行克隆或属性拷贝（ES2018）新增特性： 1let objClone = &#123;...obj&#125;; 应用场景 在函数调用时使用延展操作符 123456function (x, y, z) &#123; return x + y + z;&#125;const numbers= [1, 2, 3];console.log(sum.apply(null, numbers))console.log(sum(...numbers)) 构造数组没有延展操作符的时候，只能通过使用push, splice, concat等方法，来将已有的数组元素变成新数组的一部分。有了延展操作符，构造数组更加简单，优雅。 123const students = [\"Jack\", \"Tom\"];const persons = [\"Jony\", ...students, \"Kin\", \"Anny\"]console.log(persons) 和参数列表的展开类似，...在构造数组时，可以任意位置多次使用。 数组拷贝1234var arr = [1, 2, 4];var arr2 = [...arr]arr2.push(5)console.log(arr2) 展开语法，与object.assign()行为一致，执行的是都是浅拷贝（只遍历一层） 连接多个数组123var arr3 = [...arr1, ...arr3]// 等同与var arr4 = arr1.concat(arr2) 在ES2018中延展操作符增加了对对象的支持12345var obj1 = &#123;foo: \"baz\", x: 12&#125;;var obj2 = &#123;foo: \"bar\", y: 34&#125;;var cloneObj = &#123;...obj1&#125;;var mergeObj = &#123;...obj, ...obj2&#125;;console.log(obj1, obj2) 在React中使用通常我们在封装一个组件时，会对外公开一些props用于实现功能。大部分情况下在外部使用都应显示传递的props.但是当传递大量的props时，会非常繁琐，这时我们可以使用...延展操作符，用于取出参数对象的所有可遍历属性，来进行传递 一般情况下，我们这样传递 1&lt;CustomComponent name=\"Nyan\" age=&#123;27&#125; /&gt; 使用…，等同于上面的写法 12345const params = &#123; name: \"name\", age: 27&#125;&lt;CustomComponent &#123;...params&#125; /&gt; 配合解构赋值避免传入一些不需要的参数 1234567const params = &#123; name: \"name\", age: 27, type: \"type Name\" &#125; var &#123;type, ...other&#125; = params;&lt;CustomComponent &#123;...other&#125; /&gt; 9. 对象属性的简写在ES6中允许我们在设置一个对象的属性的时候不指定属性名 不使用es612const name= \"name\", age = 27const student = &#123;name: name,age: age, getName: function()&#123;&#125;&#125; 对象必须包含属性和值，显得非常冗余 使用Es612const name= \"name\", age = 27const student = &#123;name,age, function getName()&#123;&#125;&#125; 10. PromisePromise是异步编程的一种解决方案，比传统的解决方案callback更加优雅。它最早由社区提出与实现，ES6将其写进了语言标准，统一了写法，原生提供了Promise对象。 不使用ES6 123456setTimeout(function()&#123; console.log(\"promise test\") setTimeout(function()&#123; console.log(\"promise test 1\") &#125;, 1000)&#125;, 1000) 使用ES6 12345678910var waitSecond = new Promise(function(resolve, reject)&#123; setTimeout(resolve, 1000)&#125;);waitSeccond.then(function()&#123; console.log(\"promise test\") return waitSecond&#125;).then(function()&#123; console.log(\"promise test 1\")&#125;)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nyanshen.github.io/tags/javascript/"}]},{"title":"Javasript Variables","slug":"js-variables","date":"2019-08-01T02:34:14.000Z","updated":"2019-08-11T00:36:19.877Z","comments":true,"path":"2019/08/01/js-variables/","link":"","permalink":"https://nyanshen.github.io/2019/08/01/js-variables/","excerpt":"","text":"JavaScript 进阶问题列表1. 下面的代码输出的是什么12345678var name = \"test name\";function testVariables() &#123; console.log(name); console.log(age); var name = \"NyanShen\" let age = 27&#125;testVariables(); 在函数中，我们首先使用var关键字声明了name变量。这意味着变量在创建阶段会被提升（javascript会在创建变量创建阶段为其分配内存空间），默认值为undefined的值. 使用let关键字（和const）声明的变量也会存在变量提升，但与var不同，初始化没有被提升。在我们声明（初始化）它们之前，它们是不可被访问的。这被称为“暂时死区”。当我们在声明变量之前尝试访问变量是，javascript会抛出一个ReferenceError。 关于let的是否存在变量提升，我们可以用下面例子来验证： 12345let name = \"Nyan Test\";&#123; console.log(name); let name = \"Nyan\";&#125; let变量如果不存在变量提升，那么console.log(name)就会打印出Nyan Test,结果去抛出了ReferenceError,那么这很好的说明了let也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或未赋值时不允许访问。 要理解提升的定义，还需要搞懂js变量的执行过程 js变量的执行过程包括 1创建 =》初始化 =》 赋值 var 声明的变量执行过程 1找到当前作用域中所有var声明的变量，创建变量 =》初始化为 undefined =》**执行代码** =》 赋值 function 声明的变量执行过程 1找到当前作用域中所有function声明的变量，创建变量 =》初始化 =》赋值 =》**执行代码** let 声明的变量执行过程 1找到当前作用域中所有let声明的变量，创建变量 =》**执行代码** =》初始化为let声明的值，没有就为undefined =》 赋值（修改值） const 声明的变量执行过程 1找到当前作用域中所有let声明的变量，创建变量 =》**执行代码** =》初始化为let声明的值，没有就为undefined 有没有被提升，主要看代码执行的时机 let 的「创建」过程被提升了，但是初始化没有提升。 var 的「创建」和「初始化」都被提升了。 function 的「创建」「初始化」和「赋值」都被提升了。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nyanshen.github.io/tags/javascript/"}]}]}