{"meta":{"title":"sym blog","subtitle":"keep trying","description":"hard work will payoff","author":"Nyan Shen","url":"https://nyanshen.github.io","root":"/"},"pages":[{"title":"404","date":"2019-07-27T03:32:07.000Z","updated":"2019-08-06T05:34:40.007Z","comments":true,"path":"404/index.html","permalink":"https://nyanshen.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2019-07-27T03:31:55.000Z","updated":"2019-08-06T05:34:40.010Z","comments":true,"path":"search/index.html","permalink":"https://nyanshen.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"react typescript jest config (一)","slug":"react typescript jest config","date":"2019-08-06T11:12:11.420Z","updated":"2019-08-07T03:45:04.708Z","comments":true,"path":"2019/08/06/react typescript jest config/","link":"","permalink":"https://nyanshen.github.io/2019/08/06/react typescript jest config/","excerpt":"","text":"1. initialize projectcreate a folder projectNow we’ll turn this folder into an npm package. 1npm init -y This creates a package.json file with default values. 2. Install react typescript dependenciesFirst ensure Webpack is installed. 1npm i webpack webpack-cli webpack-merge -D Webpack is a tool that will bundle your code and optionally all of its dependencies into a single .js file. Let’s now add React and React-DOM, along with their declaration files, as dependencies to your package.json file: 12npm i react react-dom npm i @types/react @types/react-dom -D That @types/ prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like “react”, it will look inside of the react package itself; however, not all packages include declaration files, so TypeScript also looks in the @types/react package as well. You’ll see that we won’t even have to think about this later on. Next, we’ll add development-time dependencies on the ts-loader and source-map-loader. 123npm i typescript ts-loader source-map-loader -Dornpm i awesome-typescript-loader source-map-loader -D Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript’s standard configuration file named tsconfig.json. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating its own sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code. Please note that ts-loader is not the only loader for typescript. You could instead use awesome-typescript-loaderRead about the differences between them:https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loaderNotice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with npm link typescript, but this is a less common scenario. 3. Install jest enzyme dependencies1、install jest dependencies 1npm i jest @types/jest ts-jest 2、 install enzyme dependencies 12npm i enzyme enzyme-adapter-react-16 jest-enzyme enzyme-to-json -Dnpm i @types/enzyme @types/enzyme-adapter-react-16 -D install another compiler for typescript use babel dependenciesinstall babel loader 123npm i @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript -Dnpm i babel-loader babel-plugin-import -D config babel 1234567891011module.exports=&#123; presets: [ \"env\", \"react\", \"typascript\" ], plugins: [ [\"lodash\"], [\"import\", &#123;libraryName: \"antd\", style: true&#125;] ]&#125; use babel loader instaed of ts-loader","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"},{"name":"react","slug":"react","permalink":"https://nyanshen.github.io/tags/react/"},{"name":"enzyme","slug":"enzyme","permalink":"https://nyanshen.github.io/tags/enzyme/"},{"name":"typescript","slug":"typescript","permalink":"https://nyanshen.github.io/tags/typescript/"}]},{"title":"Javasript Variables","slug":"js-variables","date":"2019-08-06T05:34:40.008Z","updated":"2019-08-06T05:34:40.008Z","comments":true,"path":"2019/08/06/js-variables/","link":"","permalink":"https://nyanshen.github.io/2019/08/06/js-variables/","excerpt":"","text":"JavaScript 进阶问题列表1. 下面的代码输出的是什么12345678var name = \"test name\";function testVariables() &#123; console.log(name); console.log(age); var name = \"NyanShen\" let age = 27&#125;testVariables(); 在函数中，我们首先使用var关键字声明了name变量。这意味着变量在创建阶段会被提升（javascript会在创建变量创建阶段为其分配内存空间），默认值为undefined的值. 使用let关键字（和const）声明的变量也会存在变量提升，但与var不同，初始化没有被提升。在我们声明（初始化）它们之前，它们是不可被访问的。这被称为“暂时死区”。当我们在声明变量之前尝试访问变量是，javascript会抛出一个ReferenceError。 关于let的是否存在变量提升，我们可以用下面例子来验证： 12345let name = \"Nyan Test\";&#123; console.log(name); let name = \"Nyan\";&#125; let变量如果不存在变量提升，那么console.log(name)就会打印出Nyan Test,结果去抛出了ReferenceError,那么这很好的说明了let也存在变量提升，但是它存在一个“暂时死区”，在变量未初始化或未赋值时不允许访问。 要理解提升的定义，还需要搞懂js变量的执行过程 js变量的执行过程包括 1创建 =》初始化 =》 赋值 var 声明的变量执行过程 1找到当前作用域中所有var声明的变量，创建变量 =》初始化为 undefined =》**执行代码** =》 赋值 function 声明的变量执行过程 1找到当前作用域中所有function声明的变量，创建变量 =》初始化 =》赋值 =》**执行代码** let 声明的变量执行过程 1找到当前作用域中所有let声明的变量，创建变量 =》**执行代码** =》初始化为let声明的值，没有就为undefined =》 赋值（修改值） const 声明的变量执行过程 1找到当前作用域中所有let声明的变量，创建变量 =》**执行代码** =》初始化为let声明的值，没有就为undefined 有没有被提升，主要看代码执行的时机 let 的「创建」过程被提升了，但是初始化没有提升。 var 的「创建」和「初始化」都被提升了。 function 的「创建」「初始化」和「赋值」都被提升了。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nyanshen.github.io/tags/javascript/"}]},{"title":"jest-异步代码测试方法","slug":"jest-异步代码测试方法","date":"2019-08-06T05:34:40.008Z","updated":"2019-08-06T05:34:40.008Z","comments":true,"path":"2019/08/06/jest-异步代码测试方法/","link":"","permalink":"https://nyanshen.github.io/2019/08/06/jest-异步代码测试方法/","excerpt":"","text":"1. prepare fetch moduleLet’s implement a simple module that fetches success data from an API and returns the {success: true}. 12345678// fetchData.jsimport axios from \"axios\";export const fetchData = (fn) =&gt; &#123; axios.get('http://www.dell-lee.com/reactt/api/demo.json').then(res =&gt; &#123; fn(res.data) &#125;)&#125; In the above implementation we expect the fetchData.js module to return a promise. We chain a call to then to receive the data. 2. async function use callback type1234567// fetchData.test.jsimport &#123;fetchData&#125; from \"./fetchData.js\";test('fetchData return &#123;success: true&#125;', () =&gt; &#123; fetcchData((data) =&gt; &#123; expect(data).toEqual(&#123;success: true&#125;) &#125;)&#125;) npm run testactually it always execute successfully,because it won’t wait the async function finished. we can use done to ensure the test is execute finished. 1234567import &#123;fetchData&#125; from \"./fetchData.js\";test('fetchData return &#123;success: true&#125;', (done) =&gt; &#123; fetcchData((data) =&gt; &#123; expect(data).toEqual(&#123;success: true&#125;) done(); &#125;)&#125;) 3. return promise derectly1234567891011121314// fetchData.jsimport axios from \"axios\";export const fetchData = () =&gt; &#123; return axios.get('http://www.dell-lee.com/reactt/api/demo.json')&#125;// fetchData.test.jsimport &#123;fetchData&#125; from \"./fetchData.js\";test('fetchData return &#123;success: true&#125;', () =&gt; &#123; return fetcchData().then((res) =&gt; &#123; expect(res.data).toEqual(&#123;success: true&#125;) &#125;)&#125;) need to add return 4. Error handlingErrors can be handled using the .catch method. Make sure to add expect.assertions to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test: 12345678// fetchData.test.jstest('test fetchData return 404', () =&gt; &#123; // use assertions at least execute the expect method one time expect.assertions(1) return fetchData().catch((e) =&gt; &#123; expect(e.toString().indexOf('404') &gt; -1).toBe(true) &#125;)&#125;) 5. use resolvesThere is a less verbose way using resolves to unwrap the value of a fulfilled promise together with any other matcher. If the promise is rejected, the assertion will fail. 12345678// fetchData.test.jstest('test fetchData return &#123; success: true&#125;', () =&gt; &#123; return expect(fetchData()).resloves.toMatchObject(&#123; data: &#123; success: true &#125; &#125;)&#125;) use rejectsThe .rejects helper works like the .resolves helper. If the promise is fulfilled, the test will automatically fail. 1234// fetchData.test.jstest('test fetchData return 404', () =&gt; &#123; return expect(fetchData()).rejects.toThrow()&#125;) async/awaitWriting tests using the async/await syntax is easy. Here is how you’d write the same examples from before: 1234567891011121314151617181920// fetchData.test.jstest('test fetchData return &#123; success: true&#125;', async () =&gt; &#123; const result = await fetchData(); return expect(result.data).toEqual(&#123;success: true&#125;)&#125;)// async/await can also be used with `.resolves`.it('works with async/await and resolves', async () =&gt; &#123; expect.assertions(1); await expect(fetchData()).resolves.toEqual(&#123;success: true&#125;);&#125;);test('test fetchData return 404', async () =&gt; &#123; expect.assertions(1); try &#123; await fetchData(); &#125; catch(e) &#123; expect(e.toString()).toEqual(\"Error: Request faild with with status code 404\") &#125;&#125;)","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"}]},{"title":"Jest Setup and Teardown","slug":"Jest Setup and Teardown","date":"2019-08-06T05:34:40.007Z","updated":"2019-08-06T05:34:40.007Z","comments":true,"path":"2019/08/06/Jest Setup and Teardown/","link":"","permalink":"https://nyanshen.github.io/2019/08/06/Jest Setup and Teardown/","excerpt":"","text":"1. Repeating Setup For Many TestsIf you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach.there is a Counter Class for test like: 12345678910111213141516171819export default class Counter &#123; constructor() &#123; this.number = 0 &#125; addOne() &#123; this.number += 1 &#125; minusOne() &#123; this.number -= 1 &#125; addTwo() &#123; this.number += 2 &#125; minusTwo() &#123; this.number -= 2 &#125;&#125; you might repeat to create the instance for counter, so we can use beforeEach to prepare. 1234567891011121314import Counter from \"./counter\"let counter = nullbeforeEach(() =&gt; &#123; console.log(\"beforeEach\") counter = new Counter()&#125;)afterEach(() =&gt; &#123; console.log(\"afterEach\")&#125;)test(\"test counter addOne\", () =&gt; &#123; console.log(\"test counter addOne\") counter.addOne() expect(counter.number).toBe(1)&#125;) 2. Scoping &amp;&amp; Order of execution of describe and test blocksBy default, the before and after blocks apply to every test in a file. You can also group tests together using a describe block. When they are inside a describe block, the before and after blocks only apply to the tests within that describe block. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import Counter from \"./counter\"// describe block Applies to all tests in this filedescribe(\"counter js test\", () =&gt; &#123; let counter = null; console.log(\"counter js test\") beforeAll(() =&gt; &#123; console.log(\"beforeAll\") &#125;) beforeEach(() =&gt; &#123; console.log(\"beforeEach\") counter = new Counter(); &#125;) afterEach(() =&gt; &#123; console.log(\"afterEach\") &#125;) afterAll(() =&gt; &#123; console.log(\"afterAll\") &#125;) describe(\"counter js test add\", () =&gt; &#123; console.log(\"counter js test add\") beforeAll(() =&gt; &#123; console.log(\"beforeAll add\") &#125;) beforeEach(() =&gt; &#123; console.log(\"beforeEach add\") &#125;) afterEach(() =&gt; &#123; console.log(\"afterEach add\") &#125;) afterAll(() =&gt; &#123; console.log(\"afterAll add\") &#125;) test(\"test counter addOne\", () =&gt; &#123; console.log(\"test counter addOne\") counter.addOne() expect(counter.number).toBe(1) &#125;) &#125;) describe(\"counter js test minus\", () =&gt; &#123; // // Applies only to tests in this describe block console.log(\"counter js test minus\") test(\"test counter minusOne\", () =&gt; &#123; console.log(\"counter js test minusOne\") counter.minusOne() expect(counter.number).toBe(-1) &#125;) test(\"test counter minusTwo\", () =&gt; &#123; console.log(\"counter js test minusTwo\") counter.minusTwo() expect(counter.number).toBe(-2) &#125;) &#125;)&#125;)// execute order/** * counter js test * counter js test add * counter js test munis * beforeAll * beforeAll add * beforeEach * beforeEach add * test counter addOne * afterEach add * afterEach * afterAll add * beforeEach * counter js test minusOne * afterEach * beforeEach * counter js test minusTwo * afterEach */ 3. General Advice If a test is failing, one of the first things to check should be whether the test is failing when it’s the only test that runs. In Jest it’s simple to run only one test - just temporarily change that test command to a test.only If you have a test that often fails when it’s run as part of a larger suite, but doesn’t fail when you run it alone, it’s a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with beforeEach. If you’re not sure whether some shared state is being modified, you can also try a beforeEach that just logs data.","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"}]},{"title":"es6 新特性","slug":"es6-新特性","date":"2019-08-06T05:34:40.007Z","updated":"2019-08-06T05:34:40.007Z","comments":true,"path":"2019/08/06/es6-新特性/","link":"","permalink":"https://nyanshen.github.io/2019/08/06/es6-新特性/","excerpt":"","text":"1. 类（class）这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 12345678910111213141516171819202122232425262728293031class Animal &#123; constructor(name, color) &#123; // 构造函数 this.name = name; this.color = color; &#125; toString() &#123; // toString方法 console.log(`name: $&#123;this.name&#125;, color: $&#123;this.color&#125;`); &#125; getName() &#123; // 取值 return this.name; &#125; setName(value) &#123; // 存值 this.name = value; &#125; getColor() &#123; // 取值 return this.color; &#125; setColor(value) &#123; // 存值 this.color = value; &#125;&#125;let animal = new Animal(\"cat\", \"white\");animal.toString(); // name: cat, color: whiteconsole.log(animal.hasOwnProperty('name')) // trueconsole.log(animal.hasOwnProperty('toString')) // falseconsole.log(animal.__proto__.hasOwnProperty('toString')) // true 2. super 和 extends使用新的super和extends关键字扩展类1234567891011121314151617181920212223class Cat extends Animal &#123; constructor(action = \"catch thing\",name, color) &#123; super(\"cat\", \"black\"); // super用作函数, 必须在this使用前调用 this.action = action; // Cat 类本身属性 &#125; toString() &#123; super.toString();// super用作对象 &#125; getAction() &#123; return this.action; &#125; setAction(value) &#123; this.action = value; &#125;&#125;let cat = new Cat(\"eat fish\");cat.toString(); // name: cat, color: whiteconsole.log(cat instanceOf Cat) // trueconsole.log(cat instanceOf Animal) // true 使用ES5编写同样功能的类123456789101112131415161718192021222324function Animal(name, color) &#123; this.name = name || \"cat\"; this.color = color || \"orange\";&#125;Animal.prototype.toString = function() &#123; console.log(`name: $&#123;this.name&#125;, color: $&#123;this.color&#125;`);&#125;function Cat (action, name, color) &#123; Animal.call(this, name, color); this.action = action || \"catch thing\";&#125;Cat.prototype = Object.create(Animal.prototype);Cat.prototype.constructor = Cat;Cat.prototype.toString = function() &#123; Tree.prototype.toString.call(this);&#125;Cat.prototype.setAction = function(value) &#123; this.action = value;&#125; 3. 模块化（Module）es5不支持原生的模块化，在es6模块作为重要的组成部分被添加进来。模块的共能主要由export和import组成。每一个模块都有自己的单独的作用域，模块之间的调用是通过export来规定模块对外暴露的接口，通过import来引用其他模块提供的接口。同时模块还创造了命名空间，防止函数的命名冲突。 导出（export）ES6允许在一个模块中使用export来导出多个变量和函数。 导出变量12345export let varible = \"test variable exprot\";export default varible;let name = \"cat\";let color = \"yellow\";export &#123;name, color&#125; 导出常量1export const NUMBER_LENGTH = 20 导出函数123export function myModuleFn(somParams) &#123; return somParams&#125; 导入（import）定义好模块的输出，就可以在另一个模块通过import导入 123import varible from \"test.js\"import &#123;myModuleFn&#125; from \"myModuleFn\";import &#123;name, color&#125; from \"./path/to/test.js\"; 4. 箭头函数（Arrow Function）=&gt;不只是function的简写，它还带来了其他好处。箭头函数与包围它的代码共享同一个this，能够帮你解决this的指向问题。有经验的javaScript开发者都熟悉var self = this或var that = this这种引用外围的this的模式。但=&gt;就不需要这种模式了。 不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做别的一些事（如卸载监听器），那么你必须保存这个引用。 箭头函数与普通函数的区别 箭头函数是匿名函数，不能作为构造函数，不能使用new 箭头函数不绑定arguments，取而代之用rest参数…解决 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。 箭头函数没有原型属性 箭头函数不能当做Generator函数,不能使用yield关键字 箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()普通函数的this指向调用它的那个对象 5. 模板字符串ES6支持模板字符串，使得字符串的拼接更加简洁、直观。 不使用模板字符串 1var name = &apos;your name is &apos; + first + &apos; &apos; + last; 使用模板字符串 1var name = `your name is $&#123;first&#125; $&#123;last&#125;`; 在ES6中通过${}就可以完成字符串拼接，只需要将变量放在大括号中。 7. 解构赋值解构赋值语法是Javascript的一种表达式，可以方便的从数组或对象中快速提取值赋给定义的变量。 获取数组的值从数据中获取值并赋值到的变量中，变量的顺序与数组中对象顺序对应 123456789var foo = [&#123;\"a\": \"one\"&#125;, \"two\", \"three\", \"four\"];var [one, two, three] = foo;console.log(one, two, three)// 如果你要忽略某些值， 你可以按照下面的写法获取你想要的值var [first, , , last] = foo;console.log(first, last)var [a, b] = [1, 2]console.log(a, b) 如果没有从数组中获取到值，可以为变量设置一个默认值。 12var a ,b;[a= 3, b=7]=[1] 获取对象的值1234567const student = &#123; name: \"Nyan\", age: 27, city: \"ShenZhen\"&#125;const &#123;name, age, city&#125; = student;console.log(name, age, city) 8. 延展操作符（Spread operator）延展操作符...可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开；还可以在构造对象时，将对象表达式按key-value方式展开。 语法 函数调用 1myFunction(...iterableObj) 数组构造或字符串 1[...iterableObj, '4', ...'hello', 6] 构造对象时，进行克隆或属性拷贝（ES2018）新增特性： 1let objClone = &#123;...obj&#125;; 应用场景 在函数调用时使用延展操作符 123456function (x, y, z) &#123; return x + y + z;&#125;const numbers= [1, 2, 3];console.log(sum.apply(null, numbers))console.log(sum(...numbers)) 构造数组没有延展操作符的时候，只能通过使用push, splice, concat等方法，来将已有的数组元素变成新数组的一部分。有了延展操作符，构造数组更加简单，优雅。 123const students = [\"Jack\", \"Tom\"];const persons = [\"Jony\", ...students, \"Kin\", \"Anny\"]console.log(persons) 和参数列表的展开类似，...在构造数组时，可以任意位置多次使用。 数组拷贝1234var arr = [1, 2, 4];var arr2 = [...arr]arr2.push(5)console.log(arr2) 展开语法，与object.assign()行为一致，执行的是都是浅拷贝（只遍历一层） 连接多个数组123var arr3 = [...arr1, ...arr3]// 等同与var arr4 = arr1.concat(arr2) 在ES2018中延展操作符增加了对对象的支持12345var obj1 = &#123;foo: \"baz\", x: 12&#125;;var obj2 = &#123;foo: \"bar\", y: 34&#125;;var cloneObj = &#123;...obj1&#125;;var mergeObj = &#123;...obj, ...obj2&#125;;console.log(obj1, obj2) 在React中使用通常我们在封装一个组件时，会对外公开一些props用于实现功能。大部分情况下在外部使用都应显示传递的props.但是当传递大量的props时，会非常繁琐，这时我们可以使用...延展操作符，用于取出参数对象的所有可遍历属性，来进行传递 一般情况下，我们这样传递 1&lt;CustomComponent name=\"Nyan\" age=&#123;27&#125; /&gt; 使用…，等同于上面的写法 12345const params = &#123; name: \"name\", age: 27&#125;&lt;CustomComponent &#123;...params&#125; /&gt; 配合解构赋值避免传入一些不需要的参数 1234567const params = &#123; name: \"name\", age: 27, type: \"type Name\" &#125; var &#123;type, ...other&#125; = params;&lt;CustomComponent &#123;...other&#125; /&gt; 9. 对象属性的简写在ES6中允许我们在设置一个对象的属性的时候不指定属性名 不使用es612const name= \"name\", age = 27const student = &#123;name: name,age: age, getName: function()&#123;&#125;&#125; 对象必须包含属性和值，显得非常冗余 使用Es612const name= \"name\", age = 27const student = &#123;name,age, function getName()&#123;&#125;&#125; 10. PromisePromise是异步编程的一种解决方案，比传统的解决方案callback更加优雅。它最早由社区提出与实现，ES6将其写进了语言标准，统一了写法，原生提供了Promise对象。 不使用ES6 123456setTimeout(function()&#123; console.log(\"promise test\") setTimeout(function()&#123; console.log(\"promise test 1\") &#125;, 1000)&#125;, 1000) 使用ES6 12345678910var waitSecond = new Promise(function(resolve, reject)&#123; setTimeout(resolve, 1000)&#125;);waitSeccond.then(function()&#123; console.log(\"promise test\") return waitSecond&#125;).then(function()&#123; console.log(\"promise test 1\")&#125;)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://nyanshen.github.io/tags/javascript/"}]},{"title":"jest test todo list","slug":"jest test todo list","date":"2019-08-06T05:34:40.007Z","updated":"2019-08-06T05:34:40.007Z","comments":true,"path":"2019/08/06/jest test todo list/","link":"","permalink":"https://nyanshen.github.io/2019/08/06/jest test todo list/","excerpt":"","text":"1. Header组件单元测试header组件主要由一个title,和一个输入框组成，输入框有以下几个处理情况： 输入框初始化为空 输入框内容为空时，回车事件不做任何操作 输入框内容不为空时，回车事件会调用添加todo的函数，并且清空输入框内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// Header.jsxexport default class Header extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: \"\" &#125; this.handleKeyUp = this.handleKeyUp.bind(this); this.handleInputChange = this.handleInputChange.bind(this); &#125; handleKeyUp(e) &#123; const &#123; value &#125; = this.state; if (e.keyCode === 13 &amp;&amp; value) &#123; this.props.addUndoItem(value) this.setState(&#123;value: \"\"&#125;) &#125; &#125; handleInputChange(e) &#123; this.setState(&#123; value: e.target.value &#125;) &#125; render() &#123; const &#123; value &#125; = this.state; return ( &lt;div className=\"header\"&gt; &lt;div className=\"header-content\"&gt;TodoList &lt;input value=&#123;value&#125; data-test=\"input\" className=\"header-input\" placeholder=\"add todo\" onKeyUp=&#123;this.handleKeyUp&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;// test/Header.test.jsximport React from \"react\";import &#123; shallow &#125; from \"enzyme\";import Header from \"../Header\";import &#123; findTestWrapper &#125; from \"common/util/testUtils\"describe(\"Header Componet Test\", () =&gt; &#123; it(\"样式渲染正常\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); expect(wrapper).toMatchSnapshot(); &#125;) it(\"组件包含输入框\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); expect(inputElem.length).toBe(1); &#125;) it(\"输入框内容初始化应该为空\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); expect(inputElem.prop(\"value\")).toEqual(\"\"); &#125;) it(\"输入框随用户输入时发生改变\", () =&gt; &#123; const wrapper = shallow(&lt;Header /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); /** * 模拟change事件，输入test nyan */ inputElem.simulate(\"change\", &#123; target: &#123; value: \"test nyan\" &#125; &#125;) expect(wrapper.state(\"value\")).toEqual(\"test nyan\"); &#125;) it(\"输入框没有内容时，回车时无反应\", () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); wrapper.setState(&#123; value: \"\" &#125;) inputElem.simulate(\"kepUp\", &#123; keyCode: 13 &#125;) expect(fn).not.toHaveBeenCalled(); &#125;) it(\"输入框有内容触发回车时，函数应该被调用\", () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); // 准备数据 wrapper.setState(&#123; value: \"jest react\" &#125;) /** * 设置keyUp的keyCode模拟回车 */ inputElem.simulate(\"keyUp\", &#123; keyCode: 13 &#125;) expect(fn).toHaveBeenCalled(); expect(fn).toHaveBeenLastCalledWith(\"jest react\"); // 最后的参数 &#125;) it(\"输入框有内容触发回车时，内容应该被清除\", () =&gt; &#123; const fn = jest.fn(); const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;); const inputElem = wrapper.find(\"[data-test='input']\"); // 准备数据 wrapper.setState(&#123; value: \"jest react add one\" &#125;) /** * 设置keyUp的keyCode模拟回车 */ inputElem.simulate(\"keyUp\", &#123; keyCode: 13 &#125;) const newInputElem = wrapper.find(\"[data-test='input']\"); expect(newInputElem.prop(\"value\")).toBe(\"\"); &#125;)&#125;) 2. TodoList组件单元测试TodoList组件主要控制undoList数据状态的改变，实现改变数据项显示状态（输入框或文字）。 首先数据项undoList初始化为空 其次判断TodoList组件所包含那些子组件以及属性方法 每一个数据项都有修改和删除操作 通过状态的改变进行数据项修改 点击每一个数据项，会调用状态改变函数 当输入框失去焦点时，改变数据项的状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180import React from \"react\";import Header from \"../components/Header\"import UndoList from \"../components/UndoList\";export default class TodoList extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; undoList: [] &#125; this.deleteItem = this.deleteItem.bind(this); this.addUndoItem = this.addUndoItem.bind(this); this.changeStatus = this.changeStatus.bind(this); this.handleBlur = this.handleBlur.bind(this); this.handleValueChange = this.handleValueChange.bind(this); &#125; addUndoItem(value) &#123; this.setState(&#123; undoList: [...this.state.undoList, &#123; status: \"div\", value &#125;] &#125;) &#125; deleteItem(index) &#123; const newUndoList = [...this.state.undoList] newUndoList.splice(index, 1) this.setState(&#123; undoList: newUndoList &#125;) &#125; changeStatus(index) &#123; const newUndoList = this.state.undoList.map((item, listIndex) =&gt; &#123; if (listIndex === index) &#123; return &#123; ...item, status: \"input\" &#125; &#125; return &#123; ...item, status: \"div\" &#125; &#125;) this.setState(&#123; undoList: newUndoList &#125;) &#125; handleBlur(index) &#123; const newUndoList = this.state.undoList.map((item, listIndex) =&gt; &#123; if (listIndex === index) &#123; return &#123; ...item, status: \"div\" &#125; &#125; return item &#125;) this.setState(&#123; undoList: newUndoList &#125;) &#125; handleValueChange(index, value) &#123; const newUndoList = this.state.undoList.map((item, listIndex) =&gt; &#123; if (listIndex === index) &#123; return &#123; ...item, value &#125; &#125; return item &#125;) this.setState(&#123; undoList: newUndoList &#125;) &#125; render() &#123; const &#123; undoList &#125; = this.state; return ( &lt;&gt; &lt;Header addUndoItem=&#123;this.addUndoItem&#125; /&gt; &lt;UndoList list=&#123;undoList&#125; deleteItem=&#123;this.deleteItem&#125; changeStatus=&#123;this.changeStatus&#125; handleBlur=&#123;this.handleBlur&#125; handleValueChange=&#123;this.handleValueChange&#125; /&gt; &lt;/&gt; ) &#125;&#125;// todoList.test.jsimport React from \"react\";import &#123; shallow &#125; from \"enzyme\";import TodoList from \"../../../containers/TodoList\";describe(\"TodoList Comonent Test\", () =&gt; &#123; it(\"初始化列表为空\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); expect(wrapper.state(\"undoList\")).toEqual([]); &#125;) it(\"Header组件存在addUndoItem的属性\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const header = wrapper.find(\"Header\"); //expect(header.prop(\"addUndoItem\")).toBe(wrapper.instance().addUndoItem); expect(header.prop(\"addUndoItem\")).toBeTruthy(); &#125;) it(\"addUndoItem方法被调用时，undoList数据项新增\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); /** * const header = wrapper.find(\"Header\"); * const addFn = header.prop(\"addUndoItem\"); * addFn(\"add item one\"); * 这样操作，测试就会跟Header组件耦合（像集成测试），应该修改为一下方案 */ const content = \"add item one\" wrapper.instance().addUndoItem(content) expect(wrapper.state(\"undoList\").length).toBe(1); expect(wrapper.state(\"undoList\")[0]).toEqual(&#123; status: \"div\", value: content &#125;) &#125;) it(\"UndoList 组件应该有接收list，deleteItem，changeStatus, handleBlur属性\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const undoList = wrapper.find(\"UndoList\"); expect(undoList.prop(\"list\")).toBeTruthy(); expect(undoList.prop(\"deleteItem\")).toBeTruthy(); expect(undoList.prop(\"changeStatus\")).toBeTruthy(); expect(undoList.prop(\"handleBlur\")).toBeTruthy(); &#125;) it(\"deleteItem被执行时，应该删除对应数据项\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const data =[ &#123;status: \"div\",value: \"react\"&#125;, &#123;status: \"div\",value: \"ject\"&#125;, &#123;status: \"div\",value: \"enzyme\"&#125;, ] wrapper.setState(&#123;undoList: data&#125;); wrapper.instance().deleteItem(1); expect(wrapper.state(\"undoList\")).toEqual([data[0], data[2]]) &#125;) it(\"changeStatus被执行时，undoList数据项被修改\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const data =[ &#123;status: \"div\",value: \"react\"&#125;, &#123;status: \"div\",value: \"ject\"&#125;, &#123;status: \"div\",value: \"enzyme\"&#125;, ] wrapper.setState(&#123;undoList: data&#125;); wrapper.instance().changeStatus(1); expect(wrapper.state(\"undoList\")[1]).toEqual(&#123; ...data[1], status: \"input\" &#125;) &#125;) it(\"handleBlur被执行时，undoList数据项被修改\", () =&gt; &#123; const wrapper = shallow(&lt;TodoList /&gt;); const data =[ &#123;status: \"input\",value: \"react\"&#125;, &#123;status: \"div\",value: \"ject\"&#125;, &#123;status: \"div\",value: \"enzyme\"&#125;, ] wrapper.setState(&#123;undoList: data&#125;); wrapper.instance().handleBlur(0); expect(wrapper.state(\"undoList\")[0]).toEqual(&#123; ...data[0], status: \"div\" &#125;) &#125;)&#125;) 3. undoList组件单元测试undoList组件是TodoList组件的子组件，控制显示todoList数据，主要包含title、统计添加的todo数据项个数、显示添加的数据项，以及父亲组件传入修改的数据项。 当没有添加todo数据项时，count的长度为0 当添加了todo数据项时，显示数量以及对应的数据项 当有todo数据项时，每个数据项显示删除按钮 当有todo数据项时，点击数据项时触发改变数据项状态函数 当数据项状态为可修改时，失去焦点时触发失去失去焦点函数 当数据项状态为可修改时，修改数据时触发数据项值改变的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import React from \"react\";export default class UndoList extends React.Component &#123; render() &#123; const &#123; list, deleteItem, changeStatus, handleBlur, handleValueChange &#125; = this.props; return ( &lt;div className=\"undo-list\"&gt; &lt;div className=\"undo-list-title\"&gt; 正在进行 &lt;span className=\"undo-list-count\" data-test=\"count\"&gt;&#123;list.length&#125;&lt;/span&gt; &lt;/div&gt; &lt;ul className=\"undo-list-content\"&gt; &#123; list.map((item, index) =&gt; &#123; return ( &lt;li className=\"undo-list-item\" data-test=\"listItem\" key=&#123;`$&#123;item&#125;-$&#123;index&#125;`&#125; onClick=&#123;() =&gt; changeStatus(index)&#125; &gt; &#123;item.status === \"div\" ? item.value : ( &lt;input value=&#123;item.value&#125; data-test=\"input\" className=\"undo-list-input\" onBlur=&#123;() =&gt; handleBlur(index)&#125; onChange=&#123;(e) =&gt; handleValueChange(index, e.target.value)&#125; /&gt; )&#125; &lt;span className=\"undo-list-delete\" data-test=\"deleteItem\" onClick=&#123;(e) =&gt; &#123; e.stopPropagation() deleteItem(index) &#125;&#125;&gt;-&lt;/span&gt; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;// undoList.test.jsximport React from \"react\";import &#123; shallow &#125; from \"enzyme\";import UndoList from \"../../UndoList\";import &#123; findTestWrapper &#125; from \"../../../common/util/testUtils\";describe(\"UndoList Component Test\", () =&gt; &#123; it(\"当数据为空数组时，count为0，列表无内容\", () =&gt; &#123; const undoList = []; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const countElem = findTestWrapper(wrapper, \"count\"); const listItems = findTestWrapper(wrapper, \"listItem\"); expect(countElem.text()).toBe(\"0\"); expect(listItems.length).toEqual(0); &#125;) it(\"当数据不为空数组时，显示count，列表内容不为空\", () =&gt; &#123; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const countElem = findTestWrapper(wrapper, \"count\"); const listItems = findTestWrapper(wrapper, \"listItem\"); expect(countElem.text()).toBe(\"3\"); expect(listItems.length).toEqual(3); &#125;) it(\"当数据不为空数组时，应该有删除按钮\", () =&gt; &#123; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const deleteItem = findTestWrapper(wrapper, \"deleteItem\"); expect(deleteItem.length).toEqual(3); &#125;) it(\"当数据不为空数组时，点击某个删除按钮，调用删除方法\", () =&gt; &#123; const fn = jest.fn(); const index = 1; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; deleteItem=&#123;fn&#125; /&gt;); const deleteItem = findTestWrapper(wrapper, \"deleteItem\"); deleteItem.at(index).simulate(\"click\", &#123; stopPropagation: () =&gt; &#123; &#125; // 阻止事件冒泡 &#125;); expect(fn).toHaveBeenCalledWith(index); &#125;) it(\"当某一项被点击时，触发执行changeStatus函数\", () =&gt; &#123; const fn = jest.fn(); const index = 1; const undoList = [ &#123; status: \"div\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; changeStatus=&#123;fn&#125; /&gt;); const changeStatus = findTestWrapper(wrapper, \"listItem\"); changeStatus.at(index).simulate(\"click\"); expect(fn).toHaveBeenCalledWith(index); &#125;) it(\"当某一项的状态为‘input’时，存在一个输入框\", () =&gt; &#123; const undoList = [ &#123; status: \"input\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; /&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); expect(inputElem.length).toBe(1); &#125;) it(\"当某一项失去焦点时，执行handleBlur函数\", () =&gt; &#123; const fn = jest.fn(); const undoList = [ &#123; status: \"input\", value: \"react\" &#125;, &#123; status: \"div\", value: \"ject\" &#125;, &#123; status: \"div\", value: \"enzyme\" &#125;, ]; const wrapper = shallow(&lt;UndoList list=&#123;undoList&#125; handleBlur=&#123;fn&#125; /&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); inputElem.simulate(\"blur\"); expect(fn).toHaveBeenCalledWith(0); &#125;) it('当某一个输入框变更时，触发 handleValueChange 方法', () =&gt; &#123; const listData = [ &#123; status: 'input',value: 'jest' &#125;, ] const value = 'react'; const fn = jest.fn(); const wrapper = shallow(&lt;UndoList handleValueChange=&#123;fn&#125; list=&#123;listData&#125;/&gt;); const inputElem = findTestWrapper(wrapper, \"input\"); inputElem.simulate('change', &#123; target: &#123;value&#125; &#125;); expect(fn).toHaveBeenLastCalledWith(0, value); &#125;);&#125;)","categories":[],"tags":[{"name":"jest","slug":"jest","permalink":"https://nyanshen.github.io/tags/jest/"}]}]}